/* automatically generated by rust-bindgen 0.72.1 */

pub const LZMA_H_INTERNAL: u32 = 1;
pub const LZMA_VERSION_MAJOR: u32 = 5;
pub const LZMA_VERSION_MINOR: u32 = 8;
pub const LZMA_VERSION_PATCH: u32 = 1;
pub const LZMA_VERSION_COMMIT: &[u8; 1] = b"\0";
pub const LZMA_VERSION_STABILITY_ALPHA: u32 = 0;
pub const LZMA_VERSION_STABILITY_BETA: u32 = 1;
pub const LZMA_VERSION_STABILITY_STABLE: u32 = 2;
pub const LZMA_VERSION_STABILITY_STRING: &[u8; 1] = b"\0";
pub const LZMA_VLI_BYTES_MAX: u32 = 9;
pub const LZMA_CHECK_ID_MAX: u32 = 15;
pub const LZMA_CHECK_SIZE_MAX: u32 = 64;
pub const LZMA_FILTERS_MAX: u32 = 4;
pub const LZMA_DELTA_DIST_MIN: u32 = 1;
pub const LZMA_DELTA_DIST_MAX: u32 = 256;
pub const LZMA_LCLP_MIN: u32 = 0;
pub const LZMA_LCLP_MAX: u32 = 4;
pub const LZMA_LC_DEFAULT: u32 = 3;
pub const LZMA_LP_DEFAULT: u32 = 0;
pub const LZMA_PB_MIN: u32 = 0;
pub const LZMA_PB_MAX: u32 = 4;
pub const LZMA_PB_DEFAULT: u32 = 2;
pub const LZMA_STREAM_HEADER_SIZE: u32 = 12;
pub const LZMA_BACKWARD_SIZE_MIN: u32 = 4;
pub const LZMA_BLOCK_HEADER_SIZE_MIN: u32 = 8;
pub const LZMA_BLOCK_HEADER_SIZE_MAX: u32 = 1024;
unsafe extern "C" {
    #[doc = " \\brief       Run-time version number as an integer\n\n This allows an application to compare if it was built against the same,\n older, or newer version of liblzma that is currently running.\n\n \\return The value of LZMA_VERSION macro at the compile time of liblzma"]
    pub fn lzma_version_number() -> u32;
}
unsafe extern "C" {
    #[doc = " \\brief       Run-time version as a string\n\n This function may be useful to display which version of liblzma an\n application is currently using.\n\n \\return      Run-time version of liblzma"]
    pub fn lzma_version_string() -> *const ::std::os::raw::c_char;
}
#[doc = " \\brief       Boolean\n\n This is here because C89 doesn't have stdbool.h. To set a value for\n variables having type lzma_bool, you can use\n   - C99's 'true' and 'false' from stdbool.h;\n   - C++'s internal 'true' and 'false'; or\n   - integers one (true) and zero (false)."]
pub type lzma_bool = ::std::os::raw::c_uchar;
pub const lzma_reserved_enum_LZMA_RESERVED_ENUM: lzma_reserved_enum = 0;
#[doc = " \\brief       Type of reserved enumeration variable in structures\n\n To avoid breaking library ABI when new features are added, several\n structures contain extra variables that may be used in future. Since\n sizeof(enum) can be different than sizeof(int), and sizeof(enum) may\n even vary depending on the range of enumeration constants, we specify\n a separate type to be used for reserved enumeration variables. All\n enumeration constants in liblzma API will be non-negative and less\n than 128, which should guarantee that the ABI won't break even when\n new constants are added to existing enumerations."]
pub type lzma_reserved_enum = ::std::os::raw::c_uint;
pub const lzma_ret_LZMA_OK: lzma_ret = 0;
pub const lzma_ret_LZMA_STREAM_END: lzma_ret = 1;
pub const lzma_ret_LZMA_NO_CHECK: lzma_ret = 2;
pub const lzma_ret_LZMA_UNSUPPORTED_CHECK: lzma_ret = 3;
pub const lzma_ret_LZMA_GET_CHECK: lzma_ret = 4;
pub const lzma_ret_LZMA_MEM_ERROR: lzma_ret = 5;
pub const lzma_ret_LZMA_MEMLIMIT_ERROR: lzma_ret = 6;
pub const lzma_ret_LZMA_FORMAT_ERROR: lzma_ret = 7;
pub const lzma_ret_LZMA_OPTIONS_ERROR: lzma_ret = 8;
pub const lzma_ret_LZMA_DATA_ERROR: lzma_ret = 9;
pub const lzma_ret_LZMA_BUF_ERROR: lzma_ret = 10;
pub const lzma_ret_LZMA_PROG_ERROR: lzma_ret = 11;
pub const lzma_ret_LZMA_SEEK_NEEDED: lzma_ret = 12;
pub const lzma_ret_LZMA_RET_INTERNAL1: lzma_ret = 101;
pub const lzma_ret_LZMA_RET_INTERNAL2: lzma_ret = 102;
pub const lzma_ret_LZMA_RET_INTERNAL3: lzma_ret = 103;
pub const lzma_ret_LZMA_RET_INTERNAL4: lzma_ret = 104;
pub const lzma_ret_LZMA_RET_INTERNAL5: lzma_ret = 105;
pub const lzma_ret_LZMA_RET_INTERNAL6: lzma_ret = 106;
pub const lzma_ret_LZMA_RET_INTERNAL7: lzma_ret = 107;
pub const lzma_ret_LZMA_RET_INTERNAL8: lzma_ret = 108;
#[doc = " \\brief       Return values used by several functions in liblzma\n\n Check the descriptions of specific functions to find out which return\n values they can return. With some functions the return values may have\n more specific meanings than described here; those differences are\n described per-function basis."]
pub type lzma_ret = ::std::os::raw::c_uint;
pub const lzma_action_LZMA_RUN: lzma_action = 0;
pub const lzma_action_LZMA_SYNC_FLUSH: lzma_action = 1;
pub const lzma_action_LZMA_FULL_FLUSH: lzma_action = 2;
pub const lzma_action_LZMA_FULL_BARRIER: lzma_action = 4;
pub const lzma_action_LZMA_FINISH: lzma_action = 3;
#[doc = " \\brief       The 'action' argument for lzma_code()\n\n After the first use of LZMA_SYNC_FLUSH, LZMA_FULL_FLUSH, LZMA_FULL_BARRIER,\n or LZMA_FINISH, the same 'action' must be used until lzma_code() returns\n LZMA_STREAM_END. Also, the amount of input (that is, strm->avail_in) must\n not be modified by the application until lzma_code() returns\n LZMA_STREAM_END. Changing the 'action' or modifying the amount of input\n will make lzma_code() return LZMA_PROG_ERROR."]
pub type lzma_action = ::std::os::raw::c_uint;
#[doc = " \\brief       Custom functions for memory handling\n\n A pointer to lzma_allocator may be passed via lzma_stream structure\n to liblzma, and some advanced functions take a pointer to lzma_allocator\n as a separate function argument. The library will use the functions\n specified in lzma_allocator for memory handling instead of the default\n malloc() and free(). C++ users should note that the custom memory\n handling functions must not throw exceptions.\n\n Single-threaded mode only: liblzma doesn't make an internal copy of\n lzma_allocator. Thus, it is OK to change these function pointers in\n the middle of the coding process, but obviously it must be done\n carefully to make sure that the replacement 'free' can deallocate\n memory allocated by the earlier 'alloc' function(s).\n\n Multithreaded mode: liblzma might internally store pointers to the\n lzma_allocator given via the lzma_stream structure. The application\n must not change the allocator pointer in lzma_stream or the contents\n of the pointed lzma_allocator structure until lzma_end() has been used\n to free the memory associated with that lzma_stream. The allocation\n functions might be called simultaneously from multiple threads, and\n thus they must be thread safe."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lzma_allocator {
    #[doc = " \\brief       Pointer to a custom memory allocation function\n\n If you don't want a custom allocator, but still want\n custom free(), set this to NULL and liblzma will use\n the standard malloc().\n\n \\param       opaque  lzma_allocator.opaque (see below)\n \\param       nmemb   Number of elements like in calloc(). liblzma\n                      will always set nmemb to 1, so it is safe to\n                      ignore nmemb in a custom allocator if you like.\n                      The nmemb argument exists only for\n                      compatibility with zlib and libbzip2.\n \\param       size    Size of an element in bytes.\n                      liblzma never sets this to zero.\n\n \\return      Pointer to the beginning of a memory block of\n              'size' bytes, or NULL if allocation fails\n              for some reason. When allocation fails, functions\n              of liblzma return LZMA_MEM_ERROR.\n\n The allocator should not waste time zeroing the allocated buffers.\n This is not only about speed, but also memory usage, since the\n operating system kernel doesn't necessarily allocate the requested\n memory in physical memory until it is actually used. With small\n input files, liblzma may actually need only a fraction of the\n memory that it requested for allocation.\n\n \\note        LZMA_MEM_ERROR is also used when the size of the\n              allocation would be greater than SIZE_MAX. Thus,\n              don't assume that the custom allocator must have\n              returned NULL if some function from liblzma\n              returns LZMA_MEM_ERROR."]
    pub alloc: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            nmemb: usize,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " \\brief       Pointer to a custom memory freeing function\n\n If you don't want a custom freeing function, but still\n want a custom allocator, set this to NULL and liblzma\n will use the standard free().\n\n \\param       opaque  lzma_allocator.opaque (see below)\n \\param       ptr     Pointer returned by lzma_allocator.alloc(),\n                      or when it is set to NULL, a pointer returned\n                      by the standard malloc()."]
    pub free: ::std::option::Option<
        unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, ptr: *mut ::std::os::raw::c_void),
    >,
    #[doc = " \\brief       Pointer passed to .alloc() and .free()\n\n opaque is passed as the first argument to lzma_allocator.alloc()\n and lzma_allocator.free(). This intended to ease implementing\n custom memory allocation functions for use with liblzma.\n\n If you don't need this, you should set this to NULL."]
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lzma_internal_s {
    _unused: [u8; 0],
}
#[doc = " \\brief       Internal data structure\n\n The contents of this structure is not visible outside the library."]
pub type lzma_internal = lzma_internal_s;
#[doc = " \\brief       Passing data to and from liblzma\n\n The lzma_stream structure is used for\n  - passing pointers to input and output buffers to liblzma;\n  - defining custom memory handler functions; and\n  - holding a pointer to coder-specific internal data structures.\n\n Typical usage:\n\n  - After allocating lzma_stream (on stack or with malloc()), it must be\n    initialized to LZMA_STREAM_INIT (see LZMA_STREAM_INIT for details).\n\n  - Initialize a coder to the lzma_stream, for example by using\n    lzma_easy_encoder() or lzma_auto_decoder(). Some notes:\n      - In contrast to zlib, strm->next_in and strm->next_out are\n        ignored by all initialization functions, thus it is safe\n        to not initialize them yet.\n      - The initialization functions always set strm->total_in and\n        strm->total_out to zero.\n      - If the initialization function fails, no memory is left allocated\n        that would require freeing with lzma_end() even if some memory was\n        associated with the lzma_stream structure when the initialization\n        function was called.\n\n  - Use lzma_code() to do the actual work.\n\n  - Once the coding has been finished, the existing lzma_stream can be\n    reused. It is OK to reuse lzma_stream with different initialization\n    function without calling lzma_end() first. Old allocations are\n    automatically freed.\n\n  - Finally, use lzma_end() to free the allocated memory. lzma_end() never\n    frees the lzma_stream structure itself.\n\n Application may modify the values of total_in and total_out as it wants.\n They are updated by liblzma to match the amount of data read and\n written but aren't used for anything else except as a possible return\n values from lzma_get_progress()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lzma_stream {
    #[doc = "< Pointer to the next input byte."]
    pub next_in: *const u8,
    #[doc = "< Number of available input bytes in next_in."]
    pub avail_in: usize,
    #[doc = "< Total number of bytes read by liblzma."]
    pub total_in: u64,
    #[doc = "< Pointer to the next output position."]
    pub next_out: *mut u8,
    #[doc = "< Amount of free space in next_out."]
    pub avail_out: usize,
    #[doc = "< Total number of bytes written by liblzma."]
    pub total_out: u64,
    #[doc = " \\brief       Custom memory allocation functions\n\n In most cases this is NULL which makes liblzma use\n the standard malloc() and free().\n\n \\note        In 5.0.x this is not a const pointer."]
    pub allocator: *const lzma_allocator,
    #[doc = " Internal state is not visible to applications."]
    pub internal: *mut lzma_internal,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr1: *mut ::std::os::raw::c_void,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr2: *mut ::std::os::raw::c_void,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr3: *mut ::std::os::raw::c_void,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr4: *mut ::std::os::raw::c_void,
    #[doc = " \\brief       New seek input position for LZMA_SEEK_NEEDED\n\n When lzma_code() returns LZMA_SEEK_NEEDED, the new input position\n needed by liblzma will be available in seek_pos. The value is\n guaranteed to not exceed the file size that was specified when\n this lzma_stream was initialized.\n\n In all other situations the value of this variable is undefined."]
    pub seek_pos: u64,
    #[doc = " \\private     Reserved member."]
    pub reserved_int2: u64,
    #[doc = " \\private     Reserved member."]
    pub reserved_int3: usize,
    #[doc = " \\private     Reserved member."]
    pub reserved_int4: usize,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum1: lzma_reserved_enum,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum2: lzma_reserved_enum,
}
unsafe extern "C" {
    #[doc = " \\brief       Encode or decode data\n\n Once the lzma_stream has been successfully initialized (e.g. with\n lzma_stream_encoder()), the actual encoding or decoding is done\n using this function. The application has to update strm->next_in,\n strm->avail_in, strm->next_out, and strm->avail_out to pass input\n to and get output from liblzma.\n\n See the description of the coder-specific initialization function to find\n out what 'action' values are supported by the coder.\n\n \\param       strm    Pointer to lzma_stream that is at least initialized\n                      with LZMA_STREAM_INIT.\n \\param       action  Action for this function to take. Must be a valid\n                      lzma_action enum value.\n\n \\return      Any valid lzma_ret. See the lzma_ret enum description for more\n              information."]
    pub fn lzma_code(strm: *mut lzma_stream, action: lzma_action) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Free memory allocated for the coder data structures\n\n After lzma_end(strm), strm->internal is guaranteed to be NULL. No other\n members of the lzma_stream structure are touched.\n\n \\note        zlib indicates an error if application end()s unfinished\n              stream structure. liblzma doesn't do this, and assumes that\n              application knows what it is doing.\n\n \\param       strm    Pointer to lzma_stream that is at least initialized\n                      with LZMA_STREAM_INIT."]
    pub fn lzma_end(strm: *mut lzma_stream);
}
unsafe extern "C" {
    #[doc = " \\brief       Get progress information\n\n In single-threaded mode, applications can get progress information from\n strm->total_in and strm->total_out. In multi-threaded mode this is less\n useful because a significant amount of both input and output data gets\n buffered internally by liblzma. This makes total_in and total_out give\n misleading information and also makes the progress indicator updates\n non-smooth.\n\n This function gives realistic progress information also in multi-threaded\n mode by taking into account the progress made by each thread. In\n single-threaded mode *progress_in and *progress_out are set to\n strm->total_in and strm->total_out, respectively.\n\n \\param       strm          Pointer to lzma_stream that is at least\n                            initialized with LZMA_STREAM_INIT.\n \\param[out]  progress_in   Pointer to the number of input bytes processed.\n \\param[out]  progress_out  Pointer to the number of output bytes processed."]
    pub fn lzma_get_progress(strm: *mut lzma_stream, progress_in: *mut u64, progress_out: *mut u64);
}
unsafe extern "C" {
    #[doc = " \\brief       Get the memory usage of decoder filter chain\n\n This function is currently supported only when *strm has been initialized\n with a function that takes a memlimit argument. With other functions, you\n should use e.g. lzma_raw_encoder_memusage() or lzma_raw_decoder_memusage()\n to estimate the memory requirements.\n\n This function is useful e.g. after LZMA_MEMLIMIT_ERROR to find out how big\n the memory usage limit should have been to decode the input. Note that\n this may give misleading information if decoding .xz Streams that have\n multiple Blocks, because each Block can have different memory requirements.\n\n \\param       strm    Pointer to lzma_stream that is at least initialized\n                      with LZMA_STREAM_INIT.\n\n \\return      How much memory is currently allocated for the filter\n              decoders. If no filter chain is currently allocated,\n              some non-zero value is still returned, which is less than\n              or equal to what any filter chain would indicate as its\n              memory requirement.\n\n              If this function isn't supported by *strm or some other error\n              occurs, zero is returned."]
    pub fn lzma_memusage(strm: *const lzma_stream) -> u64;
}
unsafe extern "C" {
    #[doc = " \\brief       Get the current memory usage limit\n\n This function is supported only when *strm has been initialized with\n a function that takes a memlimit argument.\n\n \\param       strm    Pointer to lzma_stream that is at least initialized\n                      with LZMA_STREAM_INIT.\n\n \\return      On success, the current memory usage limit is returned\n              (always non-zero). On error, zero is returned."]
    pub fn lzma_memlimit_get(strm: *const lzma_stream) -> u64;
}
unsafe extern "C" {
    #[doc = " \\brief       Set the memory usage limit\n\n This function is supported only when *strm has been initialized with\n a function that takes a memlimit argument.\n\n liblzma 5.2.3 and earlier has a bug where memlimit value of 0 causes\n this function to do nothing (leaving the limit unchanged) and still\n return LZMA_OK. Later versions treat 0 as if 1 had been specified (so\n lzma_memlimit_get() will return 1 even if you specify 0 here).\n\n liblzma 5.2.6 and earlier had a bug in single-threaded .xz decoder\n (lzma_stream_decoder()) which made it impossible to continue decoding\n after LZMA_MEMLIMIT_ERROR even if the limit was increased using\n lzma_memlimit_set(). Other decoders worked correctly.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: New memory usage limit successfully set.\n              - LZMA_MEMLIMIT_ERROR: The new limit is too small.\n                The limit was not changed.\n              - LZMA_PROG_ERROR: Invalid arguments, e.g. *strm doesn't\n                support memory usage limit."]
    pub fn lzma_memlimit_set(strm: *mut lzma_stream, memlimit: u64) -> lzma_ret;
}
#[doc = " \\brief       Variable-length integer type\n\n Valid VLI values are in the range [0, LZMA_VLI_MAX]. Unknown value is\n indicated with LZMA_VLI_UNKNOWN, which is the maximum value of the\n underlying integer type.\n\n lzma_vli will be uint64_t for the foreseeable future. If a bigger size\n is needed in the future, it is guaranteed that 2 * LZMA_VLI_MAX will\n not overflow lzma_vli. This simplifies integer overflow detection."]
pub type lzma_vli = u64;
unsafe extern "C" {
    #[doc = " \\brief       Encode a variable-length integer\n\n This function has two modes: single-call and multi-call. Single-call mode\n encodes the whole integer at once; it is an error if the output buffer is\n too small. Multi-call mode saves the position in *vli_pos, and thus it is\n possible to continue encoding if the buffer becomes full before the whole\n integer has been encoded.\n\n \\param       vli       Integer to be encoded\n \\param[out]  vli_pos   How many VLI-encoded bytes have already been written\n                        out. When starting to encode a new integer in\n                        multi-call mode, *vli_pos must be set to zero.\n                        To use single-call encoding, set vli_pos to NULL.\n \\param[out]  out       Beginning of the output buffer\n \\param[out]  out_pos   The next byte will be written to out[*out_pos].\n \\param       out_size  Size of the out buffer; the first byte into\n                        which no data is written to is out[out_size].\n\n \\return      Slightly different return values are used in multi-call and\n              single-call modes.\n\n              Single-call (vli_pos == NULL):\n              - LZMA_OK: Integer successfully encoded.\n              - LZMA_PROG_ERROR: Arguments are not sane. This can be due\n                to too little output space; single-call mode doesn't use\n                LZMA_BUF_ERROR, since the application should have checked\n                the encoded size with lzma_vli_size().\n\n              Multi-call (vli_pos != NULL):\n              - LZMA_OK: So far all OK, but the integer is not\n                completely written out yet.\n              - LZMA_STREAM_END: Integer successfully encoded.\n              - LZMA_BUF_ERROR: No output space was provided.\n              - LZMA_PROG_ERROR: Arguments are not sane."]
    pub fn lzma_vli_encode(
        vli: lzma_vli,
        vli_pos: *mut usize,
        out: *mut u8,
        out_pos: *mut usize,
        out_size: usize,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Decode a variable-length integer\n\n Like lzma_vli_encode(), this function has single-call and multi-call modes.\n\n \\param[out]  vli       Pointer to decoded integer. The decoder will\n                        initialize it to zero when *vli_pos == 0, so\n                        application isn't required to initialize *vli.\n \\param[out]  vli_pos   How many bytes have already been decoded. When\n                        starting to decode a new integer in multi-call\n                        mode, *vli_pos must be initialized to zero. To\n                        use single-call decoding, set vli_pos to NULL.\n \\param       in        Beginning of the input buffer\n \\param[out]  in_pos    The next byte will be read from in[*in_pos].\n \\param       in_size   Size of the input buffer; the first byte that\n                        won't be read is in[in_size].\n\n \\return      Slightly different return values are used in multi-call and\n              single-call modes.\n\n              Single-call (vli_pos == NULL):\n              - LZMA_OK: Integer successfully decoded.\n              - LZMA_DATA_ERROR: Integer is corrupt. This includes hitting\n                the end of the input buffer before the whole integer was\n                decoded; providing no input at all will use LZMA_DATA_ERROR.\n              - LZMA_PROG_ERROR: Arguments are not sane.\n\n              Multi-call (vli_pos != NULL):\n              - LZMA_OK: So far all OK, but the integer is not\n                completely decoded yet.\n              - LZMA_STREAM_END: Integer successfully decoded.\n              - LZMA_DATA_ERROR: Integer is corrupt.\n              - LZMA_BUF_ERROR: No input was provided.\n              - LZMA_PROG_ERROR: Arguments are not sane."]
    pub fn lzma_vli_decode(
        vli: *mut lzma_vli,
        vli_pos: *mut usize,
        in_: *const u8,
        in_pos: *mut usize,
        in_size: usize,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Get the number of bytes required to encode a VLI\n\n \\param       vli       Integer whose encoded size is to be determined\n\n \\return      Number of bytes on success (1-9). If vli isn't valid,\n              zero is returned."]
    pub fn lzma_vli_size(vli: lzma_vli) -> u32;
}
pub const lzma_check_LZMA_CHECK_NONE: lzma_check = 0;
pub const lzma_check_LZMA_CHECK_CRC32: lzma_check = 1;
pub const lzma_check_LZMA_CHECK_CRC64: lzma_check = 4;
pub const lzma_check_LZMA_CHECK_SHA256: lzma_check = 10;
#[doc = " \\brief       Type of the integrity check (Check ID)\n\n The .xz format supports multiple types of checks that are calculated\n from the uncompressed data. They vary in both speed and ability to\n detect errors."]
pub type lzma_check = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " \\brief       Test if the given Check ID is supported\n\n LZMA_CHECK_NONE and LZMA_CHECK_CRC32 are always supported (even if\n liblzma is built with limited features).\n\n \\note        It is safe to call this with a value that is not in the\n              range [0, 15]; in that case the return value is always false.\n\n \\param       check   Check ID\n\n \\return      lzma_bool:\n              - true if Check ID is supported by this liblzma build.\n              - false otherwise."]
    pub fn lzma_check_is_supported(check: lzma_check) -> lzma_bool;
}
unsafe extern "C" {
    #[doc = " \\brief       Get the size of the Check field with the given Check ID\n\n Although not all Check IDs have a check algorithm associated, the size of\n every Check is already frozen. This function returns the size (in bytes) of\n the Check field with the specified Check ID. The values are:\n { 0, 4, 4, 4, 8, 8, 8, 16, 16, 16, 32, 32, 32, 64, 64, 64 }\n\n \\param       check   Check ID\n\n \\return      Size of the Check field in bytes. If the argument is not in\n              the range [0, 15], UINT32_MAX is returned."]
    pub fn lzma_check_size(check: lzma_check) -> u32;
}
unsafe extern "C" {
    #[doc = " \\brief       Calculate CRC32\n\n Calculate CRC32 using the polynomial from the IEEE 802.3 standard.\n\n \\param       buf     Pointer to the input buffer\n \\param       size    Size of the input buffer\n \\param       crc     Previously returned CRC value. This is used to\n                      calculate the CRC of a big buffer in smaller chunks.\n                      Set to zero when starting a new calculation.\n\n \\return      Updated CRC value, which can be passed to this function\n              again to continue CRC calculation."]
    pub fn lzma_crc32(buf: *const u8, size: usize, crc: u32) -> u32;
}
unsafe extern "C" {
    #[doc = " \\brief       Calculate CRC64\n\n Calculate CRC64 using the polynomial from the ECMA-182 standard.\n\n This function is used similarly to lzma_crc32().\n\n \\param       buf     Pointer to the input buffer\n \\param       size    Size of the input buffer\n \\param       crc     Previously returned CRC value. This is used to\n                      calculate the CRC of a big buffer in smaller chunks.\n                      Set to zero when starting a new calculation.\n\n \\return      Updated CRC value, which can be passed to this function\n              again to continue CRC calculation."]
    pub fn lzma_crc64(buf: *const u8, size: usize, crc: u64) -> u64;
}
unsafe extern "C" {
    #[doc = " \\brief       Get the type of the integrity check\n\n This function can be called only immediately after lzma_code() has\n returned LZMA_NO_CHECK, LZMA_UNSUPPORTED_CHECK, or LZMA_GET_CHECK.\n Calling this function in any other situation has undefined behavior.\n\n \\param       strm    Pointer to lzma_stream meeting the above conditions.\n\n \\return      Check ID in the lzma_stream, or undefined if called improperly."]
    pub fn lzma_get_check(strm: *const lzma_stream) -> lzma_check;
}
#[doc = " \\brief       Filter options\n\n This structure is used to pass a Filter ID and a pointer to the filter's\n options to liblzma. A few functions work with a single lzma_filter\n structure, while most functions expect a filter chain.\n\n A filter chain is indicated with an array of lzma_filter structures.\n The array is terminated with .id = LZMA_VLI_UNKNOWN. Thus, the filter\n array must have LZMA_FILTERS_MAX + 1 elements (that is, five) to\n be able to hold any arbitrary filter chain. This is important when\n using lzma_block_header_decode() from block.h, because a filter array\n that is too small would make liblzma write past the end of the array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lzma_filter {
    #[doc = " \\brief       Filter ID\n\n Use constants whose name begin with 'LZMA_FILTER_' to specify\n different filters. In an array of lzma_filter structures, use\n LZMA_VLI_UNKNOWN to indicate end of filters.\n\n \\note        This is not an enum, because on some systems enums\n              cannot be 64-bit."]
    pub id: lzma_vli,
    #[doc = " \\brief       Pointer to filter-specific options structure\n\n If the filter doesn't need options, set this to NULL. If id is\n set to LZMA_VLI_UNKNOWN, options is ignored, and thus\n doesn't need be initialized."]
    pub options: *mut ::std::os::raw::c_void,
}
unsafe extern "C" {
    #[doc = " \\brief       Test if the given Filter ID is supported for encoding\n\n \\param       id      Filter ID\n\n \\return      lzma_bool:\n              - true if the Filter ID is supported for encoding by this\n                liblzma build.\n             - false otherwise."]
    pub fn lzma_filter_encoder_is_supported(id: lzma_vli) -> lzma_bool;
}
unsafe extern "C" {
    #[doc = " \\brief       Test if the given Filter ID is supported for decoding\n\n \\param       id      Filter ID\n\n \\return      lzma_bool:\n              - true if the Filter ID is supported for decoding by this\n                liblzma build.\n              - false otherwise."]
    pub fn lzma_filter_decoder_is_supported(id: lzma_vli) -> lzma_bool;
}
unsafe extern "C" {
    #[doc = " \\brief       Copy the filters array\n\n Copy the Filter IDs and filter-specific options from src to dest.\n Up to LZMA_FILTERS_MAX filters are copied, plus the terminating\n .id == LZMA_VLI_UNKNOWN. Thus, dest should have at least\n LZMA_FILTERS_MAX + 1 elements space unless the caller knows that\n src is smaller than that.\n\n Unless the filter-specific options is NULL, the Filter ID has to be\n supported by liblzma, because liblzma needs to know the size of every\n filter-specific options structure. The filter-specific options are not\n validated. If options is NULL, any unsupported Filter IDs are copied\n without returning an error.\n\n Old filter-specific options in dest are not freed, so dest doesn't\n need to be initialized by the caller in any way.\n\n If an error occurs, memory possibly already allocated by this function\n is always freed. liblzma versions older than 5.2.7 may modify the dest\n array and leave its contents in an undefined state if an error occurs.\n liblzma 5.2.7 and newer only modify the dest array when returning LZMA_OK.\n\n \\param       src         Array of filters terminated with\n                          .id == LZMA_VLI_UNKNOWN.\n \\param[out]  dest        Destination filter array\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free().\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_MEM_ERROR\n              - LZMA_OPTIONS_ERROR: Unsupported Filter ID and its options\n                is not NULL.\n              - LZMA_PROG_ERROR: src or dest is NULL."]
    pub fn lzma_filters_copy(
        src: *const lzma_filter,
        dest: *mut lzma_filter,
        allocator: *const lzma_allocator,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Free the options in the array of lzma_filter structures\n\n This frees the filter chain options. The filters array itself is not freed.\n\n The filters array must have at most LZMA_FILTERS_MAX + 1 elements\n including the terminating element which must have .id = LZMA_VLI_UNKNOWN.\n For all elements before the terminating element:\n   - options will be freed using the given lzma_allocator or,\n     if allocator is NULL, using free().\n   - options will be set to NULL.\n   - id will be set to LZMA_VLI_UNKNOWN.\n\n If filters is NULL, this does nothing. Again, this never frees the\n filters array itself.\n\n \\param       filters     Array of filters terminated with\n                          .id == LZMA_VLI_UNKNOWN.\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free()."]
    pub fn lzma_filters_free(filters: *mut lzma_filter, allocator: *const lzma_allocator);
}
unsafe extern "C" {
    #[doc = " \\brief       Calculate approximate memory requirements for raw encoder\n\n This function can be used to calculate the memory requirements for\n Block and Stream encoders too because Block and Stream encoders don't\n need significantly more memory than raw encoder.\n\n \\param       filters     Array of filters terminated with\n                          .id == LZMA_VLI_UNKNOWN.\n\n \\return      Number of bytes of memory required for the given\n              filter chain when encoding or UINT64_MAX on error."]
    pub fn lzma_raw_encoder_memusage(filters: *const lzma_filter) -> u64;
}
unsafe extern "C" {
    #[doc = " \\brief       Calculate approximate memory requirements for raw decoder\n\n This function can be used to calculate the memory requirements for\n Block and Stream decoders too because Block and Stream decoders don't\n need significantly more memory than raw decoder.\n\n \\param       filters     Array of filters terminated with\n                          .id == LZMA_VLI_UNKNOWN.\n\n \\return      Number of bytes of memory required for the given\n              filter chain when decoding or UINT64_MAX on error."]
    pub fn lzma_raw_decoder_memusage(filters: *const lzma_filter) -> u64;
}
unsafe extern "C" {
    #[doc = " \\brief       Initialize raw encoder\n\n This function may be useful when implementing custom file formats.\n\n The 'action' with lzma_code() can be LZMA_RUN, LZMA_SYNC_FLUSH (if the\n filter chain supports it), or LZMA_FINISH.\n\n \\param       strm      Pointer to lzma_stream that is at least\n                        initialized with LZMA_STREAM_INIT.\n \\param       filters   Array of filters terminated with\n                        .id == LZMA_VLI_UNKNOWN.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_MEM_ERROR\n              - LZMA_OPTIONS_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_raw_encoder(strm: *mut lzma_stream, filters: *const lzma_filter) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Initialize raw decoder\n\n The initialization of raw decoder goes similarly to raw encoder.\n\n The 'action' with lzma_code() can be LZMA_RUN or LZMA_FINISH. Using\n LZMA_FINISH is not required, it is supported just for convenience.\n\n \\param       strm      Pointer to lzma_stream that is at least\n                        initialized with LZMA_STREAM_INIT.\n \\param       filters   Array of filters terminated with\n                        .id == LZMA_VLI_UNKNOWN.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_MEM_ERROR\n              - LZMA_OPTIONS_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_raw_decoder(strm: *mut lzma_stream, filters: *const lzma_filter) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Update the filter chain in the encoder\n\n This function may be called after lzma_code() has returned LZMA_STREAM_END\n when LZMA_FULL_BARRIER, LZMA_FULL_FLUSH, or LZMA_SYNC_FLUSH was used:\n\n  - After LZMA_FULL_BARRIER or LZMA_FULL_FLUSH: Single-threaded .xz Stream\n    encoder (lzma_stream_encoder()) and (since liblzma 5.4.0) multi-threaded\n    Stream encoder (lzma_stream_encoder_mt()) allow setting a new filter\n    chain to be used for the next Block(s).\n\n  - After LZMA_SYNC_FLUSH: Raw encoder (lzma_raw_encoder()),\n    Block encoder (lzma_block_encoder()), and single-threaded .xz Stream\n    encoder (lzma_stream_encoder()) allow changing certain filter-specific\n    options in the middle of encoding. The actual filters in the chain\n    (Filter IDs) must not be changed! Currently only the lc, lp, and pb\n    options of LZMA2 (not LZMA1) can be changed this way.\n\n  - In the future some filters might allow changing some of their options\n    without any barrier or flushing but currently such filters don't exist.\n\n This function may also be called when no data has been compressed yet\n although this is rarely useful. In that case, this function will behave\n as if LZMA_FULL_FLUSH (Stream encoders) or LZMA_SYNC_FLUSH (Raw or Block\n encoder) had been used right before calling this function.\n\n \\param       strm      Pointer to lzma_stream that is at least\n                        initialized with LZMA_STREAM_INIT.\n \\param       filters   Array of filters terminated with\n                        .id == LZMA_VLI_UNKNOWN.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_MEM_ERROR\n              - LZMA_MEMLIMIT_ERROR\n              - LZMA_OPTIONS_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_filters_update(strm: *mut lzma_stream, filters: *const lzma_filter) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Single-call raw encoder\n\n \\note        There is no function to calculate how big output buffer\n              would surely be big enough. (lzma_stream_buffer_bound()\n              works only for lzma_stream_buffer_encode(); raw encoder\n              won't necessarily meet that bound.)\n\n \\param       filters     Array of filters terminated with\n                          .id == LZMA_VLI_UNKNOWN.\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free().\n \\param       in          Beginning of the input buffer\n \\param       in_size     Size of the input buffer\n \\param[out]  out         Beginning of the output buffer\n \\param[out]  out_pos     The next byte will be written to out[*out_pos].\n                          *out_pos is updated only if encoding succeeds.\n \\param       out_size    Size of the out buffer; the first byte into\n                          which no data is written to is out[out_size].\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Encoding was successful.\n              - LZMA_BUF_ERROR: Not enough output buffer space.\n              - LZMA_OPTIONS_ERROR\n              - LZMA_MEM_ERROR\n              - LZMA_DATA_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_raw_buffer_encode(
        filters: *const lzma_filter,
        allocator: *const lzma_allocator,
        in_: *const u8,
        in_size: usize,
        out: *mut u8,
        out_pos: *mut usize,
        out_size: usize,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Single-call raw decoder\n\n \\param       filters     Array of filters terminated with\n                          .id == LZMA_VLI_UNKNOWN.\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free().\n \\param       in          Beginning of the input buffer\n \\param       in_pos      The next byte will be read from in[*in_pos].\n                          *in_pos is updated only if decoding succeeds.\n \\param       in_size     Size of the input buffer; the first byte that\n                          won't be read is in[in_size].\n \\param[out]  out         Beginning of the output buffer\n \\param[out]  out_pos     The next byte will be written to out[*out_pos].\n                          *out_pos is updated only if encoding succeeds.\n \\param       out_size    Size of the out buffer; the first byte into\n                          which no data is written to is out[out_size].\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Decoding was successful.\n              - LZMA_BUF_ERROR: Not enough output buffer space.\n              - LZMA_OPTIONS_ERROR\n              - LZMA_MEM_ERROR\n              - LZMA_DATA_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_raw_buffer_decode(
        filters: *const lzma_filter,
        allocator: *const lzma_allocator,
        in_: *const u8,
        in_pos: *mut usize,
        in_size: usize,
        out: *mut u8,
        out_pos: *mut usize,
        out_size: usize,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Get the size of the Filter Properties field\n\n This function may be useful when implementing custom file formats\n using the raw encoder and decoder.\n\n \\note        This function validates the Filter ID, but does not\n              necessarily validate the options. Thus, it is possible\n              that this returns LZMA_OK while the following call to\n              lzma_properties_encode() returns LZMA_OPTIONS_ERROR.\n\n \\param[out]  size    Pointer to uint32_t to hold the size of the properties\n \\param       filter  Filter ID and options (the size of the properties may\n                      vary depending on the options)\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_OPTIONS_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_properties_size(size: *mut u32, filter: *const lzma_filter) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Encode the Filter Properties field\n\n \\note        Even this function won't validate more options than actually\n              necessary. Thus, it is possible that encoding the properties\n              succeeds but using the same options to initialize the encoder\n              will fail.\n\n \\note        If lzma_properties_size() indicated that the size\n              of the Filter Properties field is zero, calling\n              lzma_properties_encode() is not required, but it\n              won't do any harm either.\n\n \\param       filter  Filter ID and options\n \\param[out]  props   Buffer to hold the encoded options. The size of\n                      the buffer must have been already determined with\n                      lzma_properties_size().\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_PROG_ERROR"]
    pub fn lzma_properties_encode(filter: *const lzma_filter, props: *mut u8) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Decode the Filter Properties field\n\n \\param       filter      filter->id must have been set to the correct\n                          Filter ID. filter->options doesn't need to be\n                          initialized (it's not freed by this function). The\n                          decoded options will be stored in filter->options;\n                          it's application's responsibility to free it when\n                          appropriate. filter->options is set to NULL if\n                          there are no properties or if an error occurs.\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free().\n                          and in case of an error, also free().\n \\param       props       Input buffer containing the properties.\n \\param       props_size  Size of the properties. This must be the exact\n                          size; giving too much or too little input will\n                          return LZMA_OPTIONS_ERROR.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_OPTIONS_ERROR\n              - LZMA_MEM_ERROR"]
    pub fn lzma_properties_decode(
        filter: *mut lzma_filter,
        allocator: *const lzma_allocator,
        props: *const u8,
        props_size: usize,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Calculate encoded size of a Filter Flags field\n\n Knowing the size of Filter Flags is useful to know when allocating\n memory to hold the encoded Filter Flags.\n\n \\note        If you need to calculate size of List of Filter Flags,\n              you need to loop over every lzma_filter entry.\n\n \\param[out]  size    Pointer to integer to hold the calculated size\n \\param       filter  Filter ID and associated options whose encoded\n                      size is to be calculated\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: *size set successfully. Note that this doesn't\n                guarantee that filter->options is valid, thus\n                lzma_filter_flags_encode() may still fail.\n              - LZMA_OPTIONS_ERROR: Unknown Filter ID or unsupported options.\n              - LZMA_PROG_ERROR: Invalid options"]
    pub fn lzma_filter_flags_size(size: *mut u32, filter: *const lzma_filter) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Encode Filter Flags into given buffer\n\n In contrast to some functions, this doesn't allocate the needed buffer.\n This is due to how this function is used internally by liblzma.\n\n \\param       filter      Filter ID and options to be encoded\n \\param[out]  out         Beginning of the output buffer\n \\param[out]  out_pos     out[*out_pos] is the next write position. This\n                          is updated by the encoder.\n \\param       out_size    out[out_size] is the first byte to not write.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Encoding was successful.\n              - LZMA_OPTIONS_ERROR: Invalid or unsupported options.\n              - LZMA_PROG_ERROR: Invalid options or not enough output\n                buffer space (you should have checked it with\n                lzma_filter_flags_size())."]
    pub fn lzma_filter_flags_encode(
        filter: *const lzma_filter,
        out: *mut u8,
        out_pos: *mut usize,
        out_size: usize,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Decode Filter Flags from given buffer\n\n The decoded result is stored into *filter. The old value of\n filter->options is not free()d. If anything other than LZMA_OK\n is returned, filter->options is set to NULL.\n\n \\param[out]  filter      Destination filter. The decoded Filter ID will\n                          be stored in filter->id. If options are needed\n                          they will be allocated and the pointer will be\n                          stored in filter->options.\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free().\n \\param       in          Beginning of the input buffer\n \\param[out]  in_pos      The next byte will be read from in[*in_pos].\n                          *in_pos is updated only if decoding succeeds.\n \\param       in_size     Size of the input buffer; the first byte that\n                          won't be read is in[in_size].\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_OPTIONS_ERROR\n              - LZMA_MEM_ERROR\n              - LZMA_DATA_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_filter_flags_decode(
        filter: *mut lzma_filter,
        allocator: *const lzma_allocator,
        in_: *const u8,
        in_pos: *mut usize,
        in_size: usize,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Convert a string to a filter chain\n\n This tries to make it easier to write applications that allow users\n to set custom compression options. This only handles the filter\n configuration (including presets) but not the number of threads,\n block size, check type, or memory limits.\n\n The input string can be either a preset or a filter chain. Presets\n begin with a digit 0-9 and may be followed by zero or more flags\n which are lower-case letters. Currently only \"e\" is supported, matching\n LZMA_PRESET_EXTREME. For partial xz command line syntax compatibility,\n a preset string may start with a single dash \"-\".\n\n A filter chain consists of one or more \"filtername:opt1=value1,opt2=value2\"\n strings separated by one or more spaces. Leading and trailing spaces are\n ignored. All names and values must be lower-case. Extra commas in the\n option list are ignored. The order of filters is significant: when\n encoding, the uncompressed input data goes to the leftmost filter first.\n Normally \"lzma2\" is the last filter in the chain.\n\n If one wishes to avoid spaces, for example, to avoid shell quoting,\n it is possible to use two dashes \"--\" instead of spaces to separate\n the filters.\n\n For xz command line compatibility, each filter may be prefixed with\n two dashes \"--\" and the colon \":\" separating the filter name from\n the options may be replaced with an equals sign \"=\".\n\n By default, only filters that can be used in the .xz format are accepted.\n To allow all filters (LZMA1) use the flag LZMA_STR_ALL_FILTERS.\n\n By default, very basic validation is done for the filter chain as a whole,\n for example, that LZMA2 is only used as the last filter in the chain.\n The validation isn't perfect though and it's possible that this function\n succeeds but using the filter chain for encoding or decoding will still\n result in LZMA_OPTIONS_ERROR. To disable this validation, use the flag\n LZMA_STR_NO_VALIDATION.\n\n The available filter names and their options are available via\n lzma_str_list_filters(). See the xz man page for the description\n of filter names and options.\n\n For command line applications, below is an example how an error message\n can be displayed. Note the use of an empty string for the field width.\n If \"^\" was used there it would create an off-by-one error except at\n the very beginning of the line.\n\n \\code{.c}\n const char *str = ...; // From user\n lzma_filter filters[LZMA_FILTERS_MAX + 1];\n int pos;\n const char *msg = lzma_str_to_filters(str, &pos, filters, 0, NULL);\n if (msg != NULL) {\n     printf(\"%s: Error in XZ compression options:\\n\", argv[0]);\n     printf(\"%s: %s\\n\", argv[0], str);\n     printf(\"%s: %*s^\\n\", argv[0], errpos, \"\");\n     printf(\"%s: %s\\n\", argv[0], msg);\n }\n \\endcode\n\n \\param       str         User-supplied string describing a preset or\n                          a filter chain. If a default value is needed and\n                          you don't know what would be good, use \"6\" since\n                          that is the default preset in xz too.\n \\param[out]  error_pos   If this isn't NULL, this value will be set on\n                          both success and on all errors. This tells the\n                          location of the error in the string. This is\n                          an int to make it straightforward to use this\n                          as printf() field width. The value is guaranteed\n                          to be in the range [0, INT_MAX] even if strlen(str)\n                          somehow was greater than INT_MAX.\n \\param[out]  filters     An array of lzma_filter structures. There must\n                          be LZMA_FILTERS_MAX + 1 (that is, five) elements\n                          in the array. The old contents are ignored so it\n                          doesn't need to be initialized. This array is\n                          modified only if this function returns NULL.\n                          Once the allocated filter options are no longer\n                          needed, lzma_filters_free() can be used to free the\n                          options (it doesn't free the filters array itself).\n \\param       flags       Bitwise-or of zero or more of the flags\n                          LZMA_STR_ALL_FILTERS and LZMA_STR_NO_VALIDATION.\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free().\n\n \\return      On success, NULL is returned. On error, a statically-allocated\n              error message is returned which together with the error_pos\n              should give some idea what is wrong."]
    pub fn lzma_str_to_filters(
        str_: *const ::std::os::raw::c_char,
        error_pos: *mut ::std::os::raw::c_int,
        filters: *mut lzma_filter,
        flags: u32,
        allocator: *const lzma_allocator,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " \\brief       Convert a filter chain to a string\n\n Use cases:\n\n   - Verbose output showing the full encoder options to the user\n     (use LZMA_STR_ENCODER in flags)\n\n   - Showing the filters and options that are required to decode a file\n     (use LZMA_STR_DECODER in flags)\n\n   - Showing the filter names without any options in informational messages\n     where the technical details aren't important (no flags). In this case\n     the .options in the filters array are ignored and may be NULL even if\n     a filter has a mandatory options structure.\n\n Note that even if the filter chain was specified using a preset,\n the resulting filter chain isn't reversed to a preset. So if you\n specify \"6\" to lzma_str_to_filters() then lzma_str_from_filters()\n will produce a string containing \"lzma2\".\n\n \\param[out]  str         On success *str will be set to point to an\n                          allocated string describing the given filter\n                          chain. Old value is ignored. On error *str is\n                          always set to NULL.\n \\param       filters     Array of filters terminated with\n                          .id == LZMA_VLI_UNKNOWN.\n \\param       flags       Bitwise-or of zero or more of the flags\n                          LZMA_STR_ENCODER, LZMA_STR_DECODER,\n                          LZMA_STR_GETOPT_LONG, and LZMA_STR_NO_SPACES.\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free().\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_OPTIONS_ERROR: Empty filter chain\n                (filters[0].id == LZMA_VLI_UNKNOWN) or the filter chain\n                includes a Filter ID that is not supported by this function.\n              - LZMA_MEM_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_str_from_filters(
        str_: *mut *mut ::std::os::raw::c_char,
        filters: *const lzma_filter,
        flags: u32,
        allocator: *const lzma_allocator,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       List available filters and/or their options (for help message)\n\n If a filter_id is given then only one line is created which contains the\n filter name. If LZMA_STR_ENCODER or LZMA_STR_DECODER is used then the\n options read by the encoder or decoder are printed on the same line.\n\n If filter_id is LZMA_VLI_UNKNOWN then all supported .xz-compatible filters\n are listed:\n\n   - If neither LZMA_STR_ENCODER nor LZMA_STR_DECODER is used then\n     the supported filter names are listed on a single line separated\n     by spaces.\n\n   - If LZMA_STR_ENCODER or LZMA_STR_DECODER is used then filters and\n     the supported options are listed one filter per line. There won't\n     be a newline after the last filter.\n\n   - If LZMA_STR_ALL_FILTERS is used then the list will include also\n     those filters that cannot be used in the .xz format (LZMA1).\n\n \\param       str         On success *str will be set to point to an\n                          allocated string listing the filters and options.\n                          Old value is ignored. On error *str is always set\n                          to NULL.\n \\param       filter_id   Filter ID or LZMA_VLI_UNKNOWN.\n \\param       flags       Bitwise-or of zero or more of the flags\n                          LZMA_STR_ALL_FILTERS, LZMA_STR_ENCODER,\n                          LZMA_STR_DECODER, and LZMA_STR_GETOPT_LONG.\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free().\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_OPTIONS_ERROR: Unsupported filter_id or flags\n              - LZMA_MEM_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_str_list_filters(
        str_: *mut *mut ::std::os::raw::c_char,
        filter_id: lzma_vli,
        flags: u32,
        allocator: *const lzma_allocator,
    ) -> lzma_ret;
}
#[doc = " \\brief       Options for BCJ filters\n\n The BCJ filters never change the size of the data. Specifying options\n for them is optional: if pointer to options is NULL, default value is\n used. You probably never need to specify options to BCJ filters, so just\n set the options pointer to NULL and be happy.\n\n If options with non-default values have been specified when encoding,\n the same options must also be specified when decoding.\n\n \\note        At the moment, none of the BCJ filters support\n              LZMA_SYNC_FLUSH. If LZMA_SYNC_FLUSH is specified,\n              LZMA_OPTIONS_ERROR will be returned. If there is need,\n              partial support for LZMA_SYNC_FLUSH can be added in future.\n              Partial means that flushing would be possible only at\n              offsets that are multiple of 2, 4, or 16 depending on\n              the filter, except x86 which cannot be made to support\n              LZMA_SYNC_FLUSH predictably."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lzma_options_bcj {
    #[doc = " \\brief       Start offset for conversions\n\n This setting is useful only when the same filter is used\n _separately_ for multiple sections of the same executable file,\n and the sections contain cross-section branch/call/jump\n instructions. In that case it is beneficial to set the start\n offset of the non-first sections so that the relative addresses\n of the cross-section branch/call/jump instructions will use the\n same absolute addresses as in the first section.\n\n When the pointer to options is NULL, the default value (zero)\n is used."]
    pub start_offset: u32,
}
unsafe extern "C" {
    #[doc = " \\brief       Raw ARM64 BCJ encoder\n\n This is for special use cases only.\n\n \\param       start_offset  The lowest 32 bits of the offset in the\n                            executable being filtered. For the ARM64\n                            filter, this must be a multiple of four.\n                            For the very best results, this should also\n                            be in sync with 4096-byte page boundaries\n                            in the executable due to how ARM64's ADRP\n                            instruction works.\n \\param       buf           Buffer to be filtered in place\n \\param       size          Size of the buffer\n\n \\return      Number of bytes that were processed in `buf`. This is at most\n              `size`. With the ARM64 filter, the return value is always\n              a multiple of 4, and at most 3 bytes are left unfiltered.\n\n \\since       5.7.1alpha"]
    pub fn lzma_bcj_arm64_encode(start_offset: u32, buf: *mut u8, size: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " \\brief       Raw ARM64 BCJ decoder\n\n See lzma_bcj_arm64_encode().\n\n \\since       5.7.1alpha"]
    pub fn lzma_bcj_arm64_decode(start_offset: u32, buf: *mut u8, size: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " \\brief       Raw RISC-V BCJ encoder\n\n This is for special use cases only.\n\n \\param       start_offset  The lowest 32 bits of the offset in the\n                            executable being filtered. For the RISC-V\n                            filter, this must be a multiple of 2.\n \\param       buf           Buffer to be filtered in place\n \\param       size          Size of the buffer\n\n \\return      Number of bytes that were processed in `buf`. This is at most\n              `size`. With the RISC-V filter, the return value is always\n              a multiple of 2, and at most 7 bytes are left unfiltered.\n\n \\since       5.7.1alpha"]
    pub fn lzma_bcj_riscv_encode(start_offset: u32, buf: *mut u8, size: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " \\brief       Raw RISC-V BCJ decoder\n\n See lzma_bcj_riscv_encode().\n\n \\since       5.7.1alpha"]
    pub fn lzma_bcj_riscv_decode(start_offset: u32, buf: *mut u8, size: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " \\brief       Raw x86 BCJ encoder\n\n This is for special use cases only.\n\n \\param       start_offset  The lowest 32 bits of the offset in the\n                            executable being filtered. For the x86\n                            filter, all values are valid.\n \\param       buf           Buffer to be filtered in place\n \\param       size          Size of the buffer\n\n \\return      Number of bytes that were processed in `buf`. This is at most\n              `size`. For the x86 filter, the return value is always\n              a multiple of 1, and at most 4 bytes are left unfiltered.\n\n \\since       5.7.1alpha"]
    pub fn lzma_bcj_x86_encode(start_offset: u32, buf: *mut u8, size: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " \\brief       Raw x86 BCJ decoder\n\n See lzma_bcj_x86_encode().\n\n \\since       5.7.1alpha"]
    pub fn lzma_bcj_x86_decode(start_offset: u32, buf: *mut u8, size: usize) -> usize;
}
pub const lzma_delta_type_LZMA_DELTA_TYPE_BYTE: lzma_delta_type = 0;
#[doc = " \\brief       Type of the delta calculation\n\n Currently only byte-wise delta is supported. Other possible types could\n be, for example, delta of 16/32/64-bit little/big endian integers, but\n these are not currently planned since byte-wise delta is almost as good."]
pub type lzma_delta_type = ::std::os::raw::c_uint;
#[doc = " \\brief       Options for the Delta filter\n\n These options are needed by both encoder and decoder."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lzma_options_delta {
    #[doc = " For now, this must always be LZMA_DELTA_TYPE_BYTE."]
    pub type_: lzma_delta_type,
    #[doc = " \\brief       Delta distance\n\n With the only currently supported type, LZMA_DELTA_TYPE_BYTE,\n the distance is as bytes.\n\n Examples:\n  - 16-bit stereo audio: distance = 4 bytes\n  - 24-bit RGB image data: distance = 3 bytes"]
    pub dist: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_int1: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_int2: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_int3: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_int4: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr1: *mut ::std::os::raw::c_void,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr2: *mut ::std::os::raw::c_void,
}
pub const lzma_match_finder_LZMA_MF_HC3: lzma_match_finder = 3;
pub const lzma_match_finder_LZMA_MF_HC4: lzma_match_finder = 4;
pub const lzma_match_finder_LZMA_MF_BT2: lzma_match_finder = 18;
pub const lzma_match_finder_LZMA_MF_BT3: lzma_match_finder = 19;
pub const lzma_match_finder_LZMA_MF_BT4: lzma_match_finder = 20;
#[doc = " \\brief       Match finders\n\n Match finder has major effect on both speed and compression ratio.\n Usually hash chains are faster than binary trees.\n\n If you will use LZMA_SYNC_FLUSH often, the hash chains may be a better\n choice, because binary trees get much higher compression ratio penalty\n with LZMA_SYNC_FLUSH.\n\n The memory usage formulas are only rough estimates, which are closest to\n reality when dict_size is a power of two. The formulas are  more complex\n in reality, and can also change a little between liblzma versions. Use\n lzma_raw_encoder_memusage() to get more accurate estimate of memory usage."]
pub type lzma_match_finder = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " \\brief       Test if given match finder is supported\n\n It is safe to call this with a value that isn't listed in\n lzma_match_finder enumeration; the return value will be false.\n\n There is no way to list which match finders are available in this\n particular liblzma version and build. It would be useless, because\n a new match finder, which the application developer wasn't aware,\n could require giving additional options to the encoder that the older\n match finders don't need.\n\n \\param       match_finder    Match finder ID\n\n \\return      lzma_bool:\n              - true if the match finder is supported by this liblzma build.\n              - false otherwise."]
    pub fn lzma_mf_is_supported(match_finder: lzma_match_finder) -> lzma_bool;
}
pub const lzma_mode_LZMA_MODE_FAST: lzma_mode = 1;
pub const lzma_mode_LZMA_MODE_NORMAL: lzma_mode = 2;
#[doc = " \\brief       Compression modes\n\n This selects the function used to analyze the data produced by the match\n finder."]
pub type lzma_mode = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " \\brief       Test if given compression mode is supported\n\n It is safe to call this with a value that isn't listed in lzma_mode\n enumeration; the return value will be false.\n\n There is no way to list which modes are available in this particular\n liblzma version and build. It would be useless, because a new compression\n mode, which the application developer wasn't aware, could require giving\n additional options to the encoder that the older modes don't need.\n\n \\param       mode    Mode ID.\n\n \\return      lzma_bool:\n              - true if the compression mode is supported by this liblzma\n                build.\n              - false otherwise."]
    pub fn lzma_mode_is_supported(mode: lzma_mode) -> lzma_bool;
}
#[doc = " \\brief       Options specific to the LZMA1 and LZMA2 filters\n\n Since LZMA1 and LZMA2 share most of the code, it's simplest to share\n the options structure too. For encoding, all but the reserved variables\n need to be initialized unless specifically mentioned otherwise.\n lzma_lzma_preset() can be used to get a good starting point.\n\n For raw decoding, both LZMA1 and LZMA2 need dict_size, preset_dict, and\n preset_dict_size (if preset_dict != NULL). LZMA1 needs also lc, lp, and pb."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lzma_options_lzma {
    #[doc = " \\brief       Dictionary size in bytes\n\n Dictionary size indicates how many bytes of the recently processed\n uncompressed data is kept in memory. One method to reduce size of\n the uncompressed data is to store distance-length pairs, which\n indicate what data to repeat from the dictionary buffer. Thus,\n the bigger the dictionary, the better the compression ratio\n usually is.\n\n Maximum size of the dictionary depends on multiple things:\n  - Memory usage limit\n  - Available address space (not a problem on 64-bit systems)\n  - Selected match finder (encoder only)\n\n Currently the maximum dictionary size for encoding is 1.5 GiB\n (i.e. (UINT32_C(1) << 30) + (UINT32_C(1) << 29)) even on 64-bit\n systems for certain match finder implementation reasons. In the\n future, there may be match finders that support bigger\n dictionaries.\n\n Decoder already supports dictionaries up to 4 GiB - 1 B (i.e.\n UINT32_MAX), so increasing the maximum dictionary size of the\n encoder won't cause problems for old decoders.\n\n Because extremely small dictionaries sizes would have unneeded\n overhead in the decoder, the minimum dictionary size is 4096 bytes.\n\n \\note        When decoding, too big dictionary does no other harm\n              than wasting memory."]
    pub dict_size: u32,
    #[doc = " \\brief       Pointer to an initial dictionary\n\n It is possible to initialize the LZ77 history window using\n a preset dictionary. It is useful when compressing many\n similar, relatively small chunks of data independently from\n each other. The preset dictionary should contain typical\n strings that occur in the files being compressed. The most\n probable strings should be near the end of the preset dictionary.\n\n This feature should be used only in special situations. For\n now, it works correctly only with raw encoding and decoding.\n Currently none of the container formats supported by\n liblzma allow preset dictionary when decoding, thus if\n you create a .xz or .lzma file with preset dictionary, it\n cannot be decoded with the regular decoder functions. In the\n future, the .xz format will likely get support for preset\n dictionary though."]
    pub preset_dict: *const u8,
    #[doc = " \\brief       Size of the preset dictionary\n\n Specifies the size of the preset dictionary. If the size is\n bigger than dict_size, only the last dict_size bytes are\n processed.\n\n This variable is read only when preset_dict is not NULL.\n If preset_dict is not NULL but preset_dict_size is zero,\n no preset dictionary is used (identical to only setting\n preset_dict to NULL)."]
    pub preset_dict_size: u32,
    #[doc = " \\brief       Number of literal context bits\n\n How many of the highest bits of the previous uncompressed\n eight-bit byte (also known as 'literal') are taken into\n account when predicting the bits of the next literal.\n\n E.g. in typical English text, an upper-case letter is\n often followed by a lower-case letter, and a lower-case\n letter is usually followed by another lower-case letter.\n In the US-ASCII character set, the highest three bits are 010\n for upper-case letters and 011 for lower-case letters.\n When lc is at least 3, the literal coding can take advantage of\n this property in the uncompressed data.\n\n There is a limit that applies to literal context bits and literal\n position bits together: lc + lp <= 4. Without this limit the\n decoding could become very slow, which could have security related\n results in some cases like email servers doing virus scanning.\n This limit also simplifies the internal implementation in liblzma.\n\n There may be LZMA1 streams that have lc + lp > 4 (maximum possible\n lc would be 8). It is not possible to decode such streams with\n liblzma."]
    pub lc: u32,
    #[doc = " \\brief       Number of literal position bits\n\n lp affects what kind of alignment in the uncompressed data is\n assumed when encoding literals. A literal is a single 8-bit byte.\n See pb below for more information about alignment."]
    pub lp: u32,
    #[doc = " \\brief       Number of position bits\n\n pb affects what kind of alignment in the uncompressed data is\n assumed in general. The default means four-byte alignment\n (2^ pb =2^2=4), which is often a good choice when there's\n no better guess.\n\n When the alignment is known, setting pb accordingly may reduce\n the file size a little. E.g. with text files having one-byte\n alignment (US-ASCII, ISO-8859-*, UTF-8), setting pb=0 can\n improve compression slightly. For UTF-16 text, pb=1 is a good\n choice. If the alignment is an odd number like 3 bytes, pb=0\n might be the best choice.\n\n Even though the assumed alignment can be adjusted with pb and\n lp, LZMA1 and LZMA2 still slightly favor 16-byte alignment.\n It might be worth taking into account when designing file formats\n that are likely to be often compressed with LZMA1 or LZMA2."]
    pub pb: u32,
    #[doc = " Compression mode"]
    pub mode: lzma_mode,
    #[doc = " \\brief       Nice length of a match\n\n This determines how many bytes the encoder compares from the match\n candidates when looking for the best match. Once a match of at\n least nice_len bytes long is found, the encoder stops looking for\n better candidates and encodes the match. (Naturally, if the found\n match is actually longer than nice_len, the actual length is\n encoded; it's not truncated to nice_len.)\n\n Bigger values usually increase the compression ratio and\n compression time. For most files, 32 to 128 is a good value,\n which gives very good compression ratio at good speed.\n\n The exact minimum value depends on the match finder. The maximum\n is 273, which is the maximum length of a match that LZMA1 and\n LZMA2 can encode."]
    pub nice_len: u32,
    #[doc = " Match finder ID"]
    pub mf: lzma_match_finder,
    #[doc = " \\brief       Maximum search depth in the match finder\n\n For every input byte, match finder searches through the hash chain\n or binary tree in a loop, each iteration going one step deeper in\n the chain or tree. The searching stops if\n  - a match of at least nice_len bytes long is found;\n  - all match candidates from the hash chain or binary tree have\n    been checked; or\n  - maximum search depth is reached.\n\n Maximum search depth is needed to prevent the match finder from\n wasting too much time in case there are lots of short match\n candidates. On the other hand, stopping the search before all\n candidates have been checked can reduce compression ratio.\n\n Setting depth to zero tells liblzma to use an automatic default\n value, that depends on the selected match finder and nice_len.\n The default is in the range [4, 200] or so (it may vary between\n liblzma versions).\n\n Using a bigger depth value than the default can increase\n compression ratio in some cases. There is no strict maximum value,\n but high values (thousands or millions) should be used with care:\n the encoder could remain fast enough with typical input, but\n malicious input could cause the match finder to slow down\n dramatically, possibly creating a denial of service attack."]
    pub depth: u32,
    #[doc = " \\brief       For LZMA_FILTER_LZMA1EXT: Extended flags\n\n This is used only with LZMA_FILTER_LZMA1EXT.\n\n Currently only one flag is supported, LZMA_LZMA1EXT_ALLOW_EOPM:\n\n   - Encoder: If the flag is set, then end marker is written just\n     like it is with LZMA_FILTER_LZMA1. Without this flag the\n     end marker isn't written and the application has to store\n     the uncompressed size somewhere outside the compressed stream.\n     To decompress streams without the end marker, the application\n     has to set the correct uncompressed size in ext_size_low and\n     ext_size_high.\n\n   - Decoder: If the uncompressed size in ext_size_low and\n     ext_size_high is set to the special value UINT64_MAX\n     (indicating unknown uncompressed size) then this flag is\n     ignored and the end marker must always be present, that is,\n     the behavior is identical to LZMA_FILTER_LZMA1.\n\n     Otherwise, if this flag isn't set, then the input stream\n     must not have the end marker; if the end marker is detected\n     then it will result in LZMA_DATA_ERROR. This is useful when\n     it is known that the stream must not have the end marker and\n     strict validation is wanted.\n\n     If this flag is set, then it is autodetected if the end marker\n     is present after the specified number of uncompressed bytes\n     has been decompressed (ext_size_low and ext_size_high). The\n     end marker isn't allowed in any other position. This behavior\n     is useful when uncompressed size is known but the end marker\n     may or may not be present. This is the case, for example,\n     in .7z files (valid .7z files that have the end marker in\n     LZMA1 streams are rare but they do exist)."]
    pub ext_flags: u32,
    #[doc = " \\brief       For LZMA_FILTER_LZMA1EXT: Uncompressed size (low bits)\n\n The 64-bit uncompressed size is needed for decompression with\n LZMA_FILTER_LZMA1EXT. The size is ignored by the encoder.\n\n The special value UINT64_MAX indicates that the uncompressed size\n is unknown and that the end of payload marker (also known as\n end of stream marker) must be present to indicate the end of\n the LZMA1 stream. Any other value indicates the expected\n uncompressed size of the LZMA1 stream. (If LZMA1 was used together\n with filters that change the size of the data then the uncompressed\n size of the LZMA1 stream could be different than the final\n uncompressed size of the filtered stream.)\n\n ext_size_low holds the least significant 32 bits of the\n uncompressed size. The most significant 32 bits must be set\n in ext_size_high. The macro lzma_set_ext_size(opt_lzma, u64size)\n can be used to set these members.\n\n The 64-bit uncompressed size is split into two uint32_t variables\n because there were no reserved uint64_t members and using the\n same options structure for LZMA_FILTER_LZMA1, LZMA_FILTER_LZMA1EXT,\n and LZMA_FILTER_LZMA2 was otherwise more convenient than having\n a new options structure for LZMA_FILTER_LZMA1EXT. (Replacing two\n uint32_t members with one uint64_t changes the ABI on some systems\n as the alignment of this struct can increase from 4 bytes to 8.)"]
    pub ext_size_low: u32,
    #[doc = " \\brief       For LZMA_FILTER_LZMA1EXT: Uncompressed size (high bits)\n\n This holds the most significant 32 bits of the uncompressed size."]
    pub ext_size_high: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_int4: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_int5: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_int6: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_int7: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_int8: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum1: lzma_reserved_enum,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum2: lzma_reserved_enum,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum3: lzma_reserved_enum,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum4: lzma_reserved_enum,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr1: *mut ::std::os::raw::c_void,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr2: *mut ::std::os::raw::c_void,
}
unsafe extern "C" {
    #[doc = " \\brief       Set a compression preset to lzma_options_lzma structure\n\n 0 is the fastest and 9 is the slowest. These match the switches -0 .. -9\n of the xz command line tool. In addition, it is possible to bitwise-or\n flags to the preset. Currently only LZMA_PRESET_EXTREME is supported.\n The flags are defined in container.h, because the flags are used also\n with lzma_easy_encoder().\n\n The preset levels are subject to changes between liblzma versions.\n\n This function is available only if LZMA1 or LZMA2 encoder has been enabled\n when building liblzma.\n\n If features (like certain match finders) have been disabled at build time,\n then the function may return success (false) even though the resulting\n LZMA1/LZMA2 options may not be usable for encoder initialization\n (LZMA_OPTIONS_ERROR).\n\n \\param[out]  options Pointer to LZMA1 or LZMA2 options to be filled\n \\param       preset  Preset level bitwse-ORed with preset flags\n\n \\return      lzma_bool:\n              - true if the preset is not supported (failure).\n              - false otherwise (success)."]
    pub fn lzma_lzma_preset(options: *mut lzma_options_lzma, preset: u32) -> lzma_bool;
}
#[doc = " \\brief       Multithreading options"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lzma_mt {
    #[doc = " \\brief       Flags\n\n Set this to zero if no flags are wanted.\n\n Encoder: No flags are currently supported.\n\n Decoder: Bitwise-or of zero or more of the decoder flags:\n - LZMA_TELL_NO_CHECK\n - LZMA_TELL_UNSUPPORTED_CHECK\n - LZMA_TELL_ANY_CHECK\n - LZMA_IGNORE_CHECK\n - LZMA_CONCATENATED\n - LZMA_FAIL_FAST"]
    pub flags: u32,
    #[doc = " \\brief       Number of worker threads to use"]
    pub threads: u32,
    #[doc = " \\brief       Encoder only: Maximum uncompressed size of a Block\n\n The encoder will start a new .xz Block every block_size bytes.\n Using LZMA_FULL_FLUSH or LZMA_FULL_BARRIER with lzma_code()\n the caller may tell liblzma to start a new Block earlier.\n\n With LZMA2, a recommended block size is 2-4 times the LZMA2\n dictionary size. With very small dictionaries, it is recommended\n to use at least 1 MiB block size for good compression ratio, even\n if this is more than four times the dictionary size. Note that\n these are only recommendations for typical use cases; feel free\n to use other values. Just keep in mind that using a block size\n less than the LZMA2 dictionary size is waste of RAM.\n\n Set this to 0 to let liblzma choose the block size depending\n on the compression options. For LZMA2 it will be 3*dict_size\n or 1 MiB, whichever is more.\n\n For each thread, about 3 * block_size bytes of memory will be\n allocated. This may change in later liblzma versions. If so,\n the memory usage will probably be reduced, not increased."]
    pub block_size: u64,
    #[doc = " \\brief       Timeout to allow lzma_code() to return early\n\n Multithreading can make liblzma consume input and produce\n output in a very bursty way: it may first read a lot of input\n to fill internal buffers, then no input or output occurs for\n a while.\n\n In single-threaded mode, lzma_code() won't return until it has\n either consumed all the input or filled the output buffer. If\n this is done in multithreaded mode, it may cause a call\n lzma_code() to take even tens of seconds, which isn't acceptable\n in all applications.\n\n To avoid very long blocking times in lzma_code(), a timeout\n (in milliseconds) may be set here. If lzma_code() would block\n longer than this number of milliseconds, it will return with\n LZMA_OK. Reasonable values are 100 ms or more. The xz command\n line tool uses 300 ms.\n\n If long blocking times are acceptable, set timeout to a special\n value of 0. This will disable the timeout mechanism and will make\n lzma_code() block until all the input is consumed or the output\n buffer has been filled.\n\n \\note        Even with a timeout, lzma_code() might sometimes take\n              a long time to return. No timing guarantees are made."]
    pub timeout: u32,
    #[doc = " \\brief       Encoder only: Compression preset\n\n The preset is set just like with lzma_easy_encoder().\n The preset is ignored if filters below is non-NULL."]
    pub preset: u32,
    #[doc = " \\brief       Encoder only: Filter chain (alternative to a preset)\n\n If this is NULL, the preset above is used. Otherwise the preset\n is ignored and the filter chain specified here is used."]
    pub filters: *const lzma_filter,
    #[doc = " \\brief       Encoder only: Integrity check type\n\n See check.h for available checks. The xz command line tool\n defaults to LZMA_CHECK_CRC64, which is a good choice if you\n are unsure."]
    pub check: lzma_check,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum1: lzma_reserved_enum,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum2: lzma_reserved_enum,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum3: lzma_reserved_enum,
    #[doc = " \\private     Reserved member."]
    pub reserved_int1: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_int2: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_int3: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_int4: u32,
    #[doc = " \\brief       Memory usage limit to reduce the number of threads\n\n Encoder: Ignored.\n\n Decoder:\n\n If the number of threads has been set so high that more than\n memlimit_threading bytes of memory would be needed, the number\n of threads will be reduced so that the memory usage will not exceed\n memlimit_threading bytes. However, if memlimit_threading cannot\n be met even in single-threaded mode, then decoding will continue\n in single-threaded mode and memlimit_threading may be exceeded\n even by a large amount. That is, memlimit_threading will never make\n lzma_code() return LZMA_MEMLIMIT_ERROR. To truly cap the memory\n usage, see memlimit_stop below.\n\n Setting memlimit_threading to UINT64_MAX or a similar huge value\n means that liblzma is allowed to keep the whole compressed file\n and the whole uncompressed file in memory in addition to the memory\n needed by the decompressor data structures used by each thread!\n In other words, a reasonable value limit must be set here or it\n will cause problems sooner or later. If you have no idea what\n a reasonable value could be, try lzma_physmem() / 4 as a starting\n point. Setting this limit will never prevent decompression of\n a file; this will only reduce the number of threads.\n\n If memlimit_threading is greater than memlimit_stop, then the value\n of memlimit_stop will be used for both."]
    pub memlimit_threading: u64,
    #[doc = " \\brief       Memory usage limit that should never be exceeded\n\n Encoder: Ignored.\n\n Decoder: If decompressing will need more than this amount of\n memory even in the single-threaded mode, then lzma_code() will\n return LZMA_MEMLIMIT_ERROR."]
    pub memlimit_stop: u64,
    #[doc = " \\private     Reserved member."]
    pub reserved_int7: u64,
    #[doc = " \\private     Reserved member."]
    pub reserved_int8: u64,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr1: *mut ::std::os::raw::c_void,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr2: *mut ::std::os::raw::c_void,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr3: *mut ::std::os::raw::c_void,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr4: *mut ::std::os::raw::c_void,
}
unsafe extern "C" {
    #[doc = " \\brief       Calculate approximate memory usage of easy encoder\n\n This function is a wrapper for lzma_raw_encoder_memusage().\n\n \\param       preset  Compression preset (level and possible flags)\n\n \\return      Number of bytes of memory required for the given\n              preset when encoding or UINT64_MAX on error."]
    pub fn lzma_easy_encoder_memusage(preset: u32) -> u64;
}
unsafe extern "C" {
    #[doc = " \\brief       Calculate approximate decoder memory usage of a preset\n\n This function is a wrapper for lzma_raw_decoder_memusage().\n\n \\param       preset  Compression preset (level and possible flags)\n\n \\return      Number of bytes of memory required to decompress a file\n              that was compressed using the given preset or UINT64_MAX\n              on error."]
    pub fn lzma_easy_decoder_memusage(preset: u32) -> u64;
}
unsafe extern "C" {
    #[doc = " \\brief       Initialize .xz Stream encoder using a preset number\n\n This function is intended for those who just want to use the basic features\n of liblzma (that is, most developers out there).\n\n If initialization fails (return value is not LZMA_OK), all the memory\n allocated for *strm by liblzma is always freed. Thus, there is no need\n to call lzma_end() after failed initialization.\n\n If initialization succeeds, use lzma_code() to do the actual encoding.\n Valid values for 'action' (the second argument of lzma_code()) are\n LZMA_RUN, LZMA_SYNC_FLUSH, LZMA_FULL_FLUSH, and LZMA_FINISH. In future,\n there may be compression levels or flags that don't support LZMA_SYNC_FLUSH.\n\n \\param       strm    Pointer to lzma_stream that is at least initialized\n                      with LZMA_STREAM_INIT.\n \\param       preset  Compression preset to use. A preset consist of level\n                      number and zero or more flags. Usually flags aren't\n                      used, so preset is simply a number [0, 9] which match\n                      the options -0 ... -9 of the xz command line tool.\n                      Additional flags can be set using bitwise-or with\n                      the preset level number, e.g. 6 | LZMA_PRESET_EXTREME.\n \\param       check   Integrity check type to use. See check.h for available\n                      checks. The xz command line tool defaults to\n                      LZMA_CHECK_CRC64, which is a good choice if you are\n                      unsure. LZMA_CHECK_CRC32 is good too as long as the\n                      uncompressed file is not many gigabytes.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Initialization succeeded. Use lzma_code() to\n                encode your data.\n              - LZMA_MEM_ERROR: Memory allocation failed.\n              - LZMA_OPTIONS_ERROR: The given compression preset is not\n                supported by this build of liblzma.\n              - LZMA_UNSUPPORTED_CHECK: The given check type is not\n                supported by this liblzma build.\n              - LZMA_PROG_ERROR: One or more of the parameters have values\n                that will never be valid. For example, strm == NULL."]
    pub fn lzma_easy_encoder(strm: *mut lzma_stream, preset: u32, check: lzma_check) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Single-call .xz Stream encoding using a preset number\n\n The maximum required output buffer size can be calculated with\n lzma_stream_buffer_bound().\n\n \\param       preset      Compression preset to use. See the description\n                          in lzma_easy_encoder().\n \\param       check       Type of the integrity check to calculate from\n                          uncompressed data.\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free().\n \\param       in          Beginning of the input buffer\n \\param       in_size     Size of the input buffer\n \\param[out]  out         Beginning of the output buffer\n \\param[out]  out_pos     The next byte will be written to out[*out_pos].\n                          *out_pos is updated only if encoding succeeds.\n \\param       out_size    Size of the out buffer; the first byte into\n                          which no data is written to is out[out_size].\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Encoding was successful.\n              - LZMA_BUF_ERROR: Not enough output buffer space.\n              - LZMA_UNSUPPORTED_CHECK\n              - LZMA_OPTIONS_ERROR\n              - LZMA_MEM_ERROR\n              - LZMA_DATA_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_easy_buffer_encode(
        preset: u32,
        check: lzma_check,
        allocator: *const lzma_allocator,
        in_: *const u8,
        in_size: usize,
        out: *mut u8,
        out_pos: *mut usize,
        out_size: usize,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Initialize .xz Stream encoder using a custom filter chain\n\n \\param       strm    Pointer to lzma_stream that is at least initialized\n                      with LZMA_STREAM_INIT.\n \\param       filters Array of filters terminated with\n                      .id == LZMA_VLI_UNKNOWN. See filters.h for more\n                      information.\n \\param       check   Type of the integrity check to calculate from\n                      uncompressed data.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Initialization was successful.\n              - LZMA_MEM_ERROR\n              - LZMA_UNSUPPORTED_CHECK\n              - LZMA_OPTIONS_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_stream_encoder(
        strm: *mut lzma_stream,
        filters: *const lzma_filter,
        check: lzma_check,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Calculate approximate memory usage of multithreaded .xz encoder\n\n Since doing the encoding in threaded mode doesn't affect the memory\n requirements of single-threaded decompressor, you can use\n lzma_easy_decoder_memusage(options->preset) or\n lzma_raw_decoder_memusage(options->filters) to calculate\n the decompressor memory requirements.\n\n \\param       options Compression options\n\n \\return      Number of bytes of memory required for encoding with the\n              given options. If an error occurs, for example due to\n              unsupported preset or filter chain, UINT64_MAX is returned."]
    pub fn lzma_stream_encoder_mt_memusage(options: *const lzma_mt) -> u64;
}
unsafe extern "C" {
    #[doc = " \\brief       Initialize multithreaded .xz Stream encoder\n\n This provides the functionality of lzma_easy_encoder() and\n lzma_stream_encoder() as a single function for multithreaded use.\n\n The supported actions for lzma_code() are LZMA_RUN, LZMA_FULL_FLUSH,\n LZMA_FULL_BARRIER, and LZMA_FINISH. Support for LZMA_SYNC_FLUSH might be\n added in the future.\n\n \\param       strm    Pointer to lzma_stream that is at least initialized\n                      with LZMA_STREAM_INIT.\n \\param       options Pointer to multithreaded compression options\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_MEM_ERROR\n              - LZMA_UNSUPPORTED_CHECK\n              - LZMA_OPTIONS_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_stream_encoder_mt(strm: *mut lzma_stream, options: *const lzma_mt) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Calculate recommended Block size for multithreaded .xz encoder\n\n This calculates a recommended Block size for multithreaded encoding given\n a filter chain. This is used internally by lzma_stream_encoder_mt() to\n determine the Block size if the block_size member is not set to the\n special value of 0 in the lzma_mt options struct.\n\n If one wishes to change the filters between Blocks, this function is\n helpful to set the block_size member of the lzma_mt struct before calling\n lzma_stream_encoder_mt(). Since the block_size member represents the\n maximum possible Block size for the multithreaded .xz encoder, one can\n use this function to find the maximum recommended Block size based on\n all planned filter chains. Otherwise, the multithreaded encoder will\n base its maximum Block size on the first filter chain used (if the\n block_size member is not set), which may unnecessarily limit the Block\n size for a later filter chain.\n\n \\param       filters   Array of filters terminated with\n                        .id == LZMA_VLI_UNKNOWN.\n\n \\return      Recommended Block size in bytes, or UINT64_MAX if\n              an error occurred."]
    pub fn lzma_mt_block_size(filters: *const lzma_filter) -> u64;
}
unsafe extern "C" {
    #[doc = " \\brief       Initialize .lzma encoder (legacy file format)\n\n The .lzma format is sometimes called the LZMA_Alone format, which is the\n reason for the name of this function. The .lzma format supports only the\n LZMA1 filter. There is no support for integrity checks like CRC32.\n\n Use this function if and only if you need to create files readable by\n legacy LZMA tools such as LZMA Utils 4.32.x. Moving to the .xz format\n is strongly recommended.\n\n The valid action values for lzma_code() are LZMA_RUN and LZMA_FINISH.\n No kind of flushing is supported, because the file format doesn't make\n it possible.\n\n \\param       strm    Pointer to lzma_stream that is at least initialized\n                      with LZMA_STREAM_INIT.\n \\param       options Pointer to encoder options\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_MEM_ERROR\n              - LZMA_OPTIONS_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_alone_encoder(
        strm: *mut lzma_stream,
        options: *const lzma_options_lzma,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Calculate output buffer size for single-call Stream encoder\n\n When trying to compress incompressible data, the encoded size will be\n slightly bigger than the input data. This function calculates how much\n output buffer space is required to be sure that lzma_stream_buffer_encode()\n doesn't return LZMA_BUF_ERROR.\n\n The calculated value is not exact, but it is guaranteed to be big enough.\n The actual maximum output space required may be slightly smaller (up to\n about 100 bytes). This should not be a problem in practice.\n\n If the calculated maximum size doesn't fit into size_t or would make the\n Stream grow past LZMA_VLI_MAX (which should never happen in practice),\n zero is returned to indicate the error.\n\n \\note        The limit calculated by this function applies only to\n              single-call encoding. Multi-call encoding may (and probably\n              will) have larger maximum expansion when encoding\n              incompressible data. Currently there is no function to\n              calculate the maximum expansion of multi-call encoding.\n\n \\param       uncompressed_size   Size in bytes of the uncompressed\n                                  input data\n\n \\return      Maximum number of bytes needed to store the compressed data."]
    pub fn lzma_stream_buffer_bound(uncompressed_size: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " \\brief       Single-call .xz Stream encoder\n\n \\param       filters     Array of filters terminated with\n                          .id == LZMA_VLI_UNKNOWN. See filters.h for more\n                          information.\n \\param       check       Type of the integrity check to calculate from\n                          uncompressed data.\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free().\n \\param       in          Beginning of the input buffer\n \\param       in_size     Size of the input buffer\n \\param[out]  out         Beginning of the output buffer\n \\param[out]  out_pos     The next byte will be written to out[*out_pos].\n                          *out_pos is updated only if encoding succeeds.\n \\param       out_size    Size of the out buffer; the first byte into\n                          which no data is written to is out[out_size].\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Encoding was successful.\n              - LZMA_BUF_ERROR: Not enough output buffer space.\n              - LZMA_UNSUPPORTED_CHECK\n              - LZMA_OPTIONS_ERROR\n              - LZMA_MEM_ERROR\n              - LZMA_DATA_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_stream_buffer_encode(
        filters: *mut lzma_filter,
        check: lzma_check,
        allocator: *const lzma_allocator,
        in_: *const u8,
        in_size: usize,
        out: *mut u8,
        out_pos: *mut usize,
        out_size: usize,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       MicroLZMA encoder\n\n The MicroLZMA format is a raw LZMA stream whose first byte (always 0x00)\n has been replaced with bitwise-negation of the LZMA properties (lc/lp/pb).\n This encoding ensures that the first byte of MicroLZMA stream is never\n 0x00. There is no end of payload marker and thus the uncompressed size\n must be stored separately. For the best error detection the dictionary\n size should be stored separately as well but alternatively one may use\n the uncompressed size as the dictionary size when decoding.\n\n With the MicroLZMA encoder, lzma_code() behaves slightly unusually.\n The action argument must be LZMA_FINISH and the return value will never be\n LZMA_OK. Thus the encoding is always done with a single lzma_code() after\n the initialization. The benefit of the combination of initialization\n function and lzma_code() is that memory allocations can be reused for\n better performance.\n\n lzma_code() will try to encode as much input as is possible to fit into\n the given output buffer. If not all input can be encoded, the stream will\n be finished without encoding all the input. The caller must check both\n input and output buffer usage after lzma_code() (total_in and total_out\n in lzma_stream can be convenient). Often lzma_code() can fill the output\n buffer completely if there is a lot of input, but sometimes a few bytes\n may remain unused because the next LZMA symbol would require more space.\n\n lzma_stream.avail_out must be at least 6. Otherwise LZMA_PROG_ERROR\n will be returned.\n\n The LZMA dictionary should be reasonably low to speed up the encoder\n re-initialization. A good value is bigger than the resulting\n uncompressed size of most of the output chunks. For example, if output\n size is 4 KiB, dictionary size of 32 KiB or 64 KiB is good. If the\n data compresses extremely well, even 128 KiB may be useful.\n\n The MicroLZMA format and this encoder variant were made with the EROFS\n file system in mind. This format may be convenient in other embedded\n uses too where many small streams are needed. XZ Embedded includes a\n decoder for this format.\n\n \\param       strm    Pointer to lzma_stream that is at least initialized\n                      with LZMA_STREAM_INIT.\n \\param       options Pointer to encoder options\n\n \\return      Possible lzma_ret values:\n              - LZMA_STREAM_END: All good. Check the amounts of input used\n                and output produced. Store the amount of input used\n                (uncompressed size) as it needs to be known to decompress\n                the data.\n              - LZMA_OPTIONS_ERROR\n              - LZMA_MEM_ERROR\n              - LZMA_PROG_ERROR: In addition to the generic reasons for this\n                error code, this may also be returned if there isn't enough\n                output space (6 bytes) to create a valid MicroLZMA stream."]
    pub fn lzma_microlzma_encoder(
        strm: *mut lzma_stream,
        options: *const lzma_options_lzma,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Initialize .xz Stream decoder\n\n \\param       strm        Pointer to lzma_stream that is at least initialized\n                          with LZMA_STREAM_INIT.\n \\param       memlimit    Memory usage limit as bytes. Use UINT64_MAX\n                          to effectively disable the limiter. liblzma\n                          5.2.3 and earlier don't allow 0 here and return\n                          LZMA_PROG_ERROR; later versions treat 0 as if 1\n                          had been specified.\n \\param       flags       Bitwise-or of zero or more of the decoder flags:\n                          LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK,\n                          LZMA_TELL_ANY_CHECK, LZMA_IGNORE_CHECK,\n                          LZMA_CONCATENATED, LZMA_FAIL_FAST\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Initialization was successful.\n              - LZMA_MEM_ERROR: Cannot allocate memory.\n              - LZMA_OPTIONS_ERROR: Unsupported flags\n              - LZMA_PROG_ERROR"]
    pub fn lzma_stream_decoder(strm: *mut lzma_stream, memlimit: u64, flags: u32) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Initialize multithreaded .xz Stream decoder\n\n The decoder can decode multiple Blocks in parallel. This requires that each\n Block Header contains the Compressed Size and Uncompressed size fields\n which are added by the multi-threaded encoder, see lzma_stream_encoder_mt().\n\n A Stream with one Block will only utilize one thread. A Stream with multiple\n Blocks but without size information in Block Headers will be processed in\n single-threaded mode in the same way as done by lzma_stream_decoder().\n Concatenated Streams are processed one Stream at a time; no inter-Stream\n parallelization is done.\n\n This function behaves like lzma_stream_decoder() when options->threads == 1\n and options->memlimit_threading <= 1.\n\n \\param       strm        Pointer to lzma_stream that is at least initialized\n                          with LZMA_STREAM_INIT.\n \\param       options     Pointer to multithreaded compression options\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Initialization was successful.\n              - LZMA_MEM_ERROR: Cannot allocate memory.\n              - LZMA_MEMLIMIT_ERROR: Memory usage limit was reached.\n              - LZMA_OPTIONS_ERROR: Unsupported flags.\n              - LZMA_PROG_ERROR"]
    pub fn lzma_stream_decoder_mt(strm: *mut lzma_stream, options: *const lzma_mt) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Decode .xz, .lzma, and .lz (lzip) files with autodetection\n\n This decoder autodetects between the .xz, .lzma, and .lz file formats,\n and calls lzma_stream_decoder(), lzma_alone_decoder(), or\n lzma_lzip_decoder() once the type of the input file has been detected.\n\n Support for .lz was added in 5.4.0.\n\n If the flag LZMA_CONCATENATED is used and the input is a .lzma file:\n For historical reasons concatenated .lzma files aren't supported.\n If there is trailing data after one .lzma stream, lzma_code() will\n return LZMA_DATA_ERROR. (lzma_alone_decoder() doesn't have such a check\n as it doesn't support any decoder flags. It will return LZMA_STREAM_END\n after one .lzma stream.)\n\n \\param       strm        Pointer to lzma_stream that is at least initialized\n                          with LZMA_STREAM_INIT.\n \\param       memlimit    Memory usage limit as bytes. Use UINT64_MAX\n                          to effectively disable the limiter. liblzma\n                          5.2.3 and earlier don't allow 0 here and return\n                          LZMA_PROG_ERROR; later versions treat 0 as if 1\n                          had been specified.\n \\param       flags       Bitwise-or of zero or more of the decoder flags:\n                          LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK,\n                          LZMA_TELL_ANY_CHECK, LZMA_IGNORE_CHECK,\n                          LZMA_CONCATENATED, LZMA_FAIL_FAST\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Initialization was successful.\n              - LZMA_MEM_ERROR: Cannot allocate memory.\n              - LZMA_OPTIONS_ERROR: Unsupported flags\n              - LZMA_PROG_ERROR"]
    pub fn lzma_auto_decoder(strm: *mut lzma_stream, memlimit: u64, flags: u32) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Initialize .lzma decoder (legacy file format)\n\n Valid 'action' arguments to lzma_code() are LZMA_RUN and LZMA_FINISH.\n There is no need to use LZMA_FINISH, but it's allowed because it may\n simplify certain types of applications.\n\n \\param       strm        Pointer to lzma_stream that is at least initialized\n                          with LZMA_STREAM_INIT.\n \\param       memlimit    Memory usage limit as bytes. Use UINT64_MAX\n                          to effectively disable the limiter. liblzma\n                          5.2.3 and earlier don't allow 0 here and return\n                          LZMA_PROG_ERROR; later versions treat 0 as if 1\n                          had been specified.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_MEM_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_alone_decoder(strm: *mut lzma_stream, memlimit: u64) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Initialize .lz (lzip) decoder (a foreign file format)\n\n This decoder supports the .lz format versions 0 and 1:\n\n   - Files in the format version 0 were produced by lzip 1.3 and older.\n     Such files aren't common but may be found from file archives\n     as a few source packages were released in this format. People\n     might have old personal files in this format too. Decompression\n     support for the format version 0 was removed in lzip 1.18.\n\n   - lzip 1.3 added decompression support for .lz format version 1 files.\n     Compression support was added in lzip 1.4.\n\n   - lzlib extends version 1 format with the Sync Flush marker. This\n     extension is only meant for lzlib use; it's not valid in normal .lz\n     files. This extension is not supported by liblzma. lzma_code() will\n     return LZMA_DATA_ERROR at the location of the Sync Flush marker.\n\n Just like with lzma_stream_decoder() for .xz files, LZMA_CONCATENATED\n should be used when decompressing normal standalone .lz files.\n\n If LZMA_CONCATENATED is used and there is non-.lz data after at least one\n valid .lz member, lzma_code() leaves lzma_stream.next_in pointing to the\n first byte of the non-.lz data and returns LZMA_STREAM_END. That is, one\n can append custom data at the end of a .lz file and the decoder will\n ignore it. An exception to this is if the first 1-3 bytes of the non-.lz\n data are identical to the .lz magic bytes (0x4C, 0x5A, 0x49, 0x50; \"LZIP\"\n in US-ASCII). In such a case the 1-3 bytes are consumed by lzma_code().\n If one wishes to locate the non-.lz data reliably, one must ensure that\n the first byte isn't 0x4C. It's best if none of the first four bytes of\n trailing data are equal to the magic bytes because if two or three bytes\n are, lzip >= 1.20 diagnoses it as a corrupt member header by default.\n\n \\param       strm        Pointer to lzma_stream that is at least initialized\n                          with LZMA_STREAM_INIT.\n \\param       memlimit    Memory usage limit as bytes. Use UINT64_MAX\n                          to effectively disable the limiter.\n \\param       flags       Bitwise-or of flags, or zero for no flags.\n                          All decoder flags listed above are supported\n                          although only LZMA_CONCATENATED and (in very rare\n                          cases) LZMA_IGNORE_CHECK are actually useful.\n                          LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK,\n                          and LZMA_FAIL_FAST do nothing. LZMA_TELL_ANY_CHECK\n                          is supported for consistency only as CRC32 is\n                          always used in the .lz format.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Initialization was successful.\n              - LZMA_MEM_ERROR: Cannot allocate memory.\n              - LZMA_OPTIONS_ERROR: Unsupported flags\n              - LZMA_PROG_ERROR"]
    pub fn lzma_lzip_decoder(strm: *mut lzma_stream, memlimit: u64, flags: u32) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Single-call .xz Stream decoder\n\n \\param       memlimit    Pointer to how much memory the decoder is allowed\n                          to allocate. The value pointed by this pointer is\n                          modified if and only if LZMA_MEMLIMIT_ERROR is\n                          returned.\n \\param       flags       Bitwise-or of zero or more of the decoder flags:\n                          LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK,\n                          LZMA_IGNORE_CHECK, LZMA_CONCATENATED,\n                          LZMA_FAIL_FAST. Note that LZMA_TELL_ANY_CHECK\n                          is not allowed and will return LZMA_PROG_ERROR.\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free().\n \\param       in          Beginning of the input buffer\n \\param       in_pos      The next byte will be read from in[*in_pos].\n                          *in_pos is updated only if decoding succeeds.\n \\param       in_size     Size of the input buffer; the first byte that\n                          won't be read is in[in_size].\n \\param[out]  out         Beginning of the output buffer\n \\param[out]  out_pos     The next byte will be written to out[*out_pos].\n                          *out_pos is updated only if decoding succeeds.\n \\param       out_size    Size of the out buffer; the first byte into\n                          which no data is written to is out[out_size].\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Decoding was successful.\n              - LZMA_FORMAT_ERROR\n              - LZMA_OPTIONS_ERROR\n              - LZMA_DATA_ERROR\n              - LZMA_NO_CHECK: This can be returned only if using\n                the LZMA_TELL_NO_CHECK flag.\n              - LZMA_UNSUPPORTED_CHECK: This can be returned only if using\n                the LZMA_TELL_UNSUPPORTED_CHECK flag.\n              - LZMA_MEM_ERROR\n              - LZMA_MEMLIMIT_ERROR: Memory usage limit was reached.\n                The minimum required memlimit value was stored to *memlimit.\n              - LZMA_BUF_ERROR: Output buffer was too small.\n              - LZMA_PROG_ERROR"]
    pub fn lzma_stream_buffer_decode(
        memlimit: *mut u64,
        flags: u32,
        allocator: *const lzma_allocator,
        in_: *const u8,
        in_pos: *mut usize,
        in_size: usize,
        out: *mut u8,
        out_pos: *mut usize,
        out_size: usize,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       MicroLZMA decoder\n\n See lzma_microlzma_encoder() for more information.\n\n The lzma_code() usage with this decoder is completely normal. The\n special behavior of lzma_code() applies to lzma_microlzma_encoder() only.\n\n \\param       strm        Pointer to lzma_stream that is at least initialized\n                          with LZMA_STREAM_INIT.\n \\param       comp_size   Compressed size of the MicroLZMA stream.\n                          The caller must somehow know this exactly.\n \\param       uncomp_size Uncompressed size of the MicroLZMA stream.\n                          If the exact uncompressed size isn't known, this\n                          can be set to a value that is at most as big as\n                          the exact uncompressed size would be, but then the\n                          next argument uncomp_size_is_exact must be false.\n \\param       uncomp_size_is_exact\n                          If true, uncomp_size must be exactly correct.\n                          This will improve error detection at the end of\n                          the stream. If the exact uncompressed size isn't\n                          known, this must be false. uncomp_size must still\n                          be at most as big as the exact uncompressed size\n                          is. Setting this to false when the exact size is\n                          known will work but error detection at the end of\n                          the stream will be weaker.\n \\param       dict_size   LZMA dictionary size that was used when\n                          compressing the data. It is OK to use a bigger\n                          value too but liblzma will then allocate more\n                          memory than would actually be required and error\n                          detection will be slightly worse. (Note that with\n                          the implementation in XZ Embedded it doesn't\n                          affect the memory usage if one specifies bigger\n                          dictionary than actually required.)\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_MEM_ERROR\n              - LZMA_OPTIONS_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_microlzma_decoder(
        strm: *mut lzma_stream,
        comp_size: u64,
        uncomp_size: u64,
        uncomp_size_is_exact: lzma_bool,
        dict_size: u32,
    ) -> lzma_ret;
}
#[doc = " \\brief       Options for encoding/decoding Stream Header and Stream Footer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lzma_stream_flags {
    #[doc = " \\brief       Stream Flags format version\n\n To prevent API and ABI breakages if new features are needed in\n Stream Header or Stream Footer, a version number is used to\n indicate which members in this structure are in use. For now,\n version must always be zero. With non-zero version, the\n lzma_stream_header_encode() and lzma_stream_footer_encode()\n will return LZMA_OPTIONS_ERROR.\n\n lzma_stream_header_decode() and lzma_stream_footer_decode()\n will always set this to the lowest value that supports all the\n features indicated by the Stream Flags field. The application\n must check that the version number set by the decoding functions\n is supported by the application. Otherwise it is possible that\n the application will decode the Stream incorrectly."]
    pub version: u32,
    #[doc = " \\brief       Backward Size\n\n Backward Size must be a multiple of four bytes. In this Stream\n format version, Backward Size is the size of the Index field.\n\n Backward Size isn't actually part of the Stream Flags field, but\n it is convenient to include in this structure anyway. Backward\n Size is present only in the Stream Footer. There is no need to\n initialize backward_size when encoding Stream Header.\n\n lzma_stream_header_decode() always sets backward_size to\n LZMA_VLI_UNKNOWN so that it is convenient to use\n lzma_stream_flags_compare() when both Stream Header and Stream\n Footer have been decoded."]
    pub backward_size: lzma_vli,
    #[doc = " \\brief       Check ID\n\n This indicates the type of the integrity check calculated from\n uncompressed data."]
    pub check: lzma_check,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum1: lzma_reserved_enum,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum2: lzma_reserved_enum,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum3: lzma_reserved_enum,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum4: lzma_reserved_enum,
    #[doc = " \\private     Reserved member."]
    pub reserved_bool1: lzma_bool,
    #[doc = " \\private     Reserved member."]
    pub reserved_bool2: lzma_bool,
    #[doc = " \\private     Reserved member."]
    pub reserved_bool3: lzma_bool,
    #[doc = " \\private     Reserved member."]
    pub reserved_bool4: lzma_bool,
    #[doc = " \\private     Reserved member."]
    pub reserved_bool5: lzma_bool,
    #[doc = " \\private     Reserved member."]
    pub reserved_bool6: lzma_bool,
    #[doc = " \\private     Reserved member."]
    pub reserved_bool7: lzma_bool,
    #[doc = " \\private     Reserved member."]
    pub reserved_bool8: lzma_bool,
    #[doc = " \\private     Reserved member."]
    pub reserved_int1: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_int2: u32,
}
unsafe extern "C" {
    #[doc = " \\brief       Encode Stream Header\n\n \\param       options     Stream Header options to be encoded.\n                          options->backward_size is ignored and doesn't\n                          need to be initialized.\n \\param[out]  out         Beginning of the output buffer of\n                          LZMA_STREAM_HEADER_SIZE bytes.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Encoding was successful.\n              - LZMA_OPTIONS_ERROR: options->version is not supported by\n                this liblzma version.\n              - LZMA_PROG_ERROR: Invalid options."]
    pub fn lzma_stream_header_encode(options: *const lzma_stream_flags, out: *mut u8) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Encode Stream Footer\n\n \\param       options     Stream Footer options to be encoded.\n \\param[out]  out         Beginning of the output buffer of\n                          LZMA_STREAM_HEADER_SIZE bytes.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Encoding was successful.\n              - LZMA_OPTIONS_ERROR: options->version is not supported by\n                this liblzma version.\n              - LZMA_PROG_ERROR: Invalid options."]
    pub fn lzma_stream_footer_encode(options: *const lzma_stream_flags, out: *mut u8) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Decode Stream Header\n\n options->backward_size is always set to LZMA_VLI_UNKNOWN. This is to\n help comparing Stream Flags from Stream Header and Stream Footer with\n lzma_stream_flags_compare().\n\n \\note        When decoding .xz files that contain multiple Streams, it may\n              make sense to print \"file format not recognized\" only if\n              decoding of the Stream Header of the \\a first Stream gives\n              LZMA_FORMAT_ERROR. If non-first Stream Header gives\n              LZMA_FORMAT_ERROR, the message used for LZMA_DATA_ERROR is\n              probably more appropriate.\n              For example, the Stream decoder in liblzma uses\n              LZMA_DATA_ERROR if LZMA_FORMAT_ERROR is returned by\n              lzma_stream_header_decode() when decoding non-first Stream.\n\n \\param[out]  options     Target for the decoded Stream Header options.\n \\param       in          Beginning of the input buffer of\n                          LZMA_STREAM_HEADER_SIZE bytes.\n\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Decoding was successful.\n              - LZMA_FORMAT_ERROR: Magic bytes don't match, thus the given\n                buffer cannot be Stream Header.\n              - LZMA_DATA_ERROR: CRC32 doesn't match, thus the header\n                is corrupt.\n              - LZMA_OPTIONS_ERROR: Unsupported options are present\n                in the header."]
    pub fn lzma_stream_header_decode(options: *mut lzma_stream_flags, in_: *const u8) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Decode Stream Footer\n\n \\note        If Stream Header was already decoded successfully, but\n              decoding Stream Footer returns LZMA_FORMAT_ERROR, the\n              application should probably report some other error message\n              than \"file format not recognized\". The file likely\n              is corrupt (possibly truncated). The Stream decoder in liblzma\n              uses LZMA_DATA_ERROR in this situation.\n\n \\param[out]  options     Target for the decoded Stream Footer options.\n \\param       in          Beginning of the input buffer of\n                          LZMA_STREAM_HEADER_SIZE bytes.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Decoding was successful.\n              - LZMA_FORMAT_ERROR: Magic bytes don't match, thus the given\n                buffer cannot be Stream Footer.\n              - LZMA_DATA_ERROR: CRC32 doesn't match, thus the Stream Footer\n                is corrupt.\n              - LZMA_OPTIONS_ERROR: Unsupported options are present\n                in Stream Footer."]
    pub fn lzma_stream_footer_decode(options: *mut lzma_stream_flags, in_: *const u8) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Compare two lzma_stream_flags structures\n\n backward_size values are compared only if both are not\n LZMA_VLI_UNKNOWN.\n\n \\param       a       Pointer to lzma_stream_flags structure\n \\param       b       Pointer to lzma_stream_flags structure\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Both are equal. If either had backward_size set\n                to LZMA_VLI_UNKNOWN, backward_size values were not\n                compared or validated.\n              - LZMA_DATA_ERROR: The structures differ.\n              - LZMA_OPTIONS_ERROR: version in either structure is greater\n                than the maximum supported version (currently zero).\n              - LZMA_PROG_ERROR: Invalid value, e.g. invalid check or\n                backward_size."]
    pub fn lzma_stream_flags_compare(
        a: *const lzma_stream_flags,
        b: *const lzma_stream_flags,
    ) -> lzma_ret;
}
#[doc = " \\brief       Options for the Block and Block Header encoders and decoders\n\n Different Block handling functions use different parts of this structure.\n Some read some members, other functions write, and some do both. Only the\n members listed for reading need to be initialized when the specified\n functions are called. The members marked for writing will be assigned\n new values at some point either by calling the given function or by\n later calls to lzma_code()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lzma_block {
    #[doc = " \\brief       Block format version\n\n To prevent API and ABI breakages when new features are needed,\n a version number is used to indicate which members in this\n structure are in use:\n   - liblzma >= 5.0.0: version = 0 is supported.\n   - liblzma >= 5.1.4beta: Support for version = 1 was added,\n     which adds the ignore_check member.\n\n If version is greater than one, most Block related functions\n will return LZMA_OPTIONS_ERROR (lzma_block_header_decode() works\n with any version value).\n\n Read by:\n  - lzma_block_header_size()\n  - lzma_block_header_encode()\n  - lzma_block_header_decode()\n  - lzma_block_compressed_size()\n  - lzma_block_unpadded_size()\n  - lzma_block_total_size()\n  - lzma_block_encoder()\n  - lzma_block_decoder()\n  - lzma_block_buffer_encode()\n  - lzma_block_uncomp_encode()\n  - lzma_block_buffer_decode()\n\n Written by:\n  - lzma_block_header_decode()"]
    pub version: u32,
    #[doc = " \\brief       Size of the Block Header field in bytes\n\n This is always a multiple of four.\n\n Read by:\n  - lzma_block_header_encode()\n  - lzma_block_header_decode()\n  - lzma_block_compressed_size()\n  - lzma_block_unpadded_size()\n  - lzma_block_total_size()\n  - lzma_block_decoder()\n  - lzma_block_buffer_decode()\n\n Written by:\n  - lzma_block_header_size()\n  - lzma_block_buffer_encode()\n  - lzma_block_uncomp_encode()"]
    pub header_size: u32,
    #[doc = " \\brief       Type of integrity Check\n\n The Check ID is not stored into the Block Header, thus its value\n must be provided also when decoding.\n\n Read by:\n  - lzma_block_header_encode()\n  - lzma_block_header_decode()\n  - lzma_block_compressed_size()\n  - lzma_block_unpadded_size()\n  - lzma_block_total_size()\n  - lzma_block_encoder()\n  - lzma_block_decoder()\n  - lzma_block_buffer_encode()\n  - lzma_block_buffer_decode()"]
    pub check: lzma_check,
    #[doc = " \\brief       Size of the Compressed Data in bytes\n\n Encoding: If this is not LZMA_VLI_UNKNOWN, Block Header encoder\n will store this value to the Block Header. Block encoder doesn't\n care about this value, but will set it once the encoding has been\n finished.\n\n Decoding: If this is not LZMA_VLI_UNKNOWN, Block decoder will\n verify that the size of the Compressed Data field matches\n compressed_size.\n\n Usually you don't know this value when encoding in streamed mode,\n and thus cannot write this field into the Block Header.\n\n In non-streamed mode you can reserve space for this field before\n encoding the actual Block. After encoding the data, finish the\n Block by encoding the Block Header. Steps in detail:\n\n  - Set compressed_size to some big enough value. If you don't know\n    better, use LZMA_VLI_MAX, but remember that bigger values take\n    more space in Block Header.\n\n  - Call lzma_block_header_size() to see how much space you need to\n    reserve for the Block Header.\n\n  - Encode the Block using lzma_block_encoder() and lzma_code().\n    It sets compressed_size to the correct value.\n\n  - Use lzma_block_header_encode() to encode the Block Header.\n    Because space was reserved in the first step, you don't need\n    to call lzma_block_header_size() anymore, because due to\n    reserving, header_size has to be big enough. If it is \"too big\",\n    lzma_block_header_encode() will add enough Header Padding to\n    make Block Header to match the size specified by header_size.\n\n Read by:\n  - lzma_block_header_size()\n  - lzma_block_header_encode()\n  - lzma_block_compressed_size()\n  - lzma_block_unpadded_size()\n  - lzma_block_total_size()\n  - lzma_block_decoder()\n  - lzma_block_buffer_decode()\n\n Written by:\n  - lzma_block_header_decode()\n  - lzma_block_compressed_size()\n  - lzma_block_encoder()\n  - lzma_block_decoder()\n  - lzma_block_buffer_encode()\n  - lzma_block_uncomp_encode()\n  - lzma_block_buffer_decode()"]
    pub compressed_size: lzma_vli,
    #[doc = " \\brief       Uncompressed Size in bytes\n\n This is handled very similarly to compressed_size above.\n\n uncompressed_size is needed by fewer functions than\n compressed_size. This is because uncompressed_size isn't\n needed to validate that Block stays within proper limits.\n\n Read by:\n  - lzma_block_header_size()\n  - lzma_block_header_encode()\n  - lzma_block_decoder()\n  - lzma_block_buffer_decode()\n\n Written by:\n  - lzma_block_header_decode()\n  - lzma_block_encoder()\n  - lzma_block_decoder()\n  - lzma_block_buffer_encode()\n  - lzma_block_uncomp_encode()\n  - lzma_block_buffer_decode()"]
    pub uncompressed_size: lzma_vli,
    #[doc = " \\brief       Array of filters\n\n There can be 1-4 filters. The end of the array is marked with\n .id = LZMA_VLI_UNKNOWN.\n\n Read by:\n  - lzma_block_header_size()\n  - lzma_block_header_encode()\n  - lzma_block_encoder()\n  - lzma_block_decoder()\n  - lzma_block_buffer_encode()\n  - lzma_block_buffer_decode()\n\n Written by:\n  - lzma_block_header_decode(): Note that this does NOT free()\n    the old filter options structures. All unused filters[] will\n    have .id == LZMA_VLI_UNKNOWN and .options == NULL. If\n    decoding fails, all filters[] are guaranteed to be\n    LZMA_VLI_UNKNOWN and NULL.\n\n \\note        Because of the array is terminated with\n              .id = LZMA_VLI_UNKNOWN, the actual array must\n              have LZMA_FILTERS_MAX + 1 members or the Block\n              Header decoder will overflow the buffer."]
    pub filters: *mut lzma_filter,
    #[doc = " \\brief       Raw value stored in the Check field\n\n After successful coding, the first lzma_check_size(check) bytes\n of this array contain the raw value stored in the Check field.\n\n Note that CRC32 and CRC64 are stored in little endian byte order.\n Take it into account if you display the Check values to the user.\n\n Written by:\n  - lzma_block_encoder()\n  - lzma_block_decoder()\n  - lzma_block_buffer_encode()\n  - lzma_block_uncomp_encode()\n  - lzma_block_buffer_decode()"]
    pub raw_check: [u8; 64usize],
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr1: *mut ::std::os::raw::c_void,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr2: *mut ::std::os::raw::c_void,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr3: *mut ::std::os::raw::c_void,
    #[doc = " \\private     Reserved member."]
    pub reserved_int1: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_int2: u32,
    #[doc = " \\private     Reserved member."]
    pub reserved_int3: lzma_vli,
    #[doc = " \\private     Reserved member."]
    pub reserved_int4: lzma_vli,
    #[doc = " \\private     Reserved member."]
    pub reserved_int5: lzma_vli,
    #[doc = " \\private     Reserved member."]
    pub reserved_int6: lzma_vli,
    #[doc = " \\private     Reserved member."]
    pub reserved_int7: lzma_vli,
    #[doc = " \\private     Reserved member."]
    pub reserved_int8: lzma_vli,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum1: lzma_reserved_enum,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum2: lzma_reserved_enum,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum3: lzma_reserved_enum,
    #[doc = " \\private     Reserved member."]
    pub reserved_enum4: lzma_reserved_enum,
    #[doc = " \\brief       A flag to Block decoder to not verify the Check field\n\n This member is supported by liblzma >= 5.1.4beta if .version >= 1.\n\n If this is set to true, the integrity check won't be calculated\n and verified. Unless you know what you are doing, you should\n leave this to false. (A reason to set this to true is when the\n file integrity is verified externally anyway and you want to\n speed up the decompression, which matters mostly when using\n SHA-256 as the integrity check.)\n\n If .version >= 1, read by:\n   - lzma_block_decoder()\n   - lzma_block_buffer_decode()\n\n Written by (.version is ignored):\n   - lzma_block_header_decode() always sets this to false"]
    pub ignore_check: lzma_bool,
    #[doc = " \\private     Reserved member."]
    pub reserved_bool2: lzma_bool,
    #[doc = " \\private     Reserved member."]
    pub reserved_bool3: lzma_bool,
    #[doc = " \\private     Reserved member."]
    pub reserved_bool4: lzma_bool,
    #[doc = " \\private     Reserved member."]
    pub reserved_bool5: lzma_bool,
    #[doc = " \\private     Reserved member."]
    pub reserved_bool6: lzma_bool,
    #[doc = " \\private     Reserved member."]
    pub reserved_bool7: lzma_bool,
    #[doc = " \\private     Reserved member."]
    pub reserved_bool8: lzma_bool,
}
unsafe extern "C" {
    #[doc = " \\brief       Calculate Block Header Size\n\n Calculate the minimum size needed for the Block Header field using the\n settings specified in the lzma_block structure. Note that it is OK to\n increase the calculated header_size value as long as it is a multiple of\n four and doesn't exceed LZMA_BLOCK_HEADER_SIZE_MAX. Increasing header_size\n just means that lzma_block_header_encode() will add Header Padding.\n\n \\note        This doesn't check that all the options are valid i.e. this\n              may return LZMA_OK even if lzma_block_header_encode() or\n              lzma_block_encoder() would fail. If you want to validate the\n              filter chain, consider using lzma_memlimit_encoder() which as\n              a side-effect validates the filter chain.\n\n \\param       block   Block options\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Size calculated successfully and stored to\n                block->header_size.\n              - LZMA_OPTIONS_ERROR: Unsupported version, filters or\n                filter options.\n              - LZMA_PROG_ERROR: Invalid values like compressed_size == 0."]
    pub fn lzma_block_header_size(block: *mut lzma_block) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Encode Block Header\n\n The caller must have calculated the size of the Block Header already with\n lzma_block_header_size(). If a value larger than the one calculated by\n lzma_block_header_size() is used, the Block Header will be padded to the\n specified size.\n\n \\param       block       Block options to be encoded.\n \\param[out]  out         Beginning of the output buffer. This must be\n                          at least block->header_size bytes.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Encoding was successful. block->header_size\n                bytes were written to output buffer.\n              - LZMA_OPTIONS_ERROR: Invalid or unsupported options.\n              - LZMA_PROG_ERROR: Invalid arguments, for example\n                block->header_size is invalid or block->filters is NULL."]
    pub fn lzma_block_header_encode(block: *const lzma_block, out: *mut u8) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Decode Block Header\n\n block->version should (usually) be set to the highest value supported\n by the application. If the application sets block->version to a value\n higher than supported by the current liblzma version, this function will\n downgrade block->version to the highest value supported by it. Thus one\n should check the value of block->version after calling this function if\n block->version was set to a non-zero value and the application doesn't\n otherwise know that the liblzma version being used is new enough to\n support the specified block->version.\n\n The size of the Block Header must have already been decoded with\n lzma_block_header_size_decode() macro and stored to block->header_size.\n\n The integrity check type from Stream Header must have been stored\n to block->check.\n\n block->filters must have been allocated, but they don't need to be\n initialized (possible existing filter options are not freed).\n\n \\param[out]  block       Destination for Block options\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() (and also free()\n                          if an error occurs).\n \\param       in          Beginning of the input buffer. This must be\n                          at least block->header_size bytes.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Decoding was successful. block->header_size\n                bytes were read from the input buffer.\n              - LZMA_OPTIONS_ERROR: The Block Header specifies some\n                unsupported options such as unsupported filters. This can\n                happen also if block->version was set to a too low value\n                compared to what would be required to properly represent\n                the information stored in the Block Header.\n              - LZMA_DATA_ERROR: Block Header is corrupt, for example,\n                the CRC32 doesn't match.\n              - LZMA_PROG_ERROR: Invalid arguments, for example\n                block->header_size is invalid or block->filters is NULL."]
    pub fn lzma_block_header_decode(
        block: *mut lzma_block,
        allocator: *const lzma_allocator,
        in_: *const u8,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Validate and set Compressed Size according to Unpadded Size\n\n Block Header stores Compressed Size, but Index has Unpadded Size. If the\n application has already parsed the Index and is now decoding Blocks,\n it can calculate Compressed Size from Unpadded Size. This function does\n exactly that with error checking:\n\n  - Compressed Size calculated from Unpadded Size must be positive integer,\n    that is, Unpadded Size must be big enough that after Block Header and\n    Check fields there's still at least one byte for Compressed Size.\n\n  - If Compressed Size was present in Block Header, the new value\n    calculated from Unpadded Size is compared against the value\n    from Block Header.\n\n \\note        This function must be called _after_ decoding the Block Header\n              field so that it can properly validate Compressed Size if it\n              was present in Block Header.\n\n \\param       block           Block options: block->header_size must\n                              already be set with lzma_block_header_size().\n \\param       unpadded_size   Unpadded Size from the Index field in bytes\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: block->compressed_size was set successfully.\n              - LZMA_DATA_ERROR: unpadded_size is too small compared to\n                block->header_size and lzma_check_size(block->check).\n              - LZMA_PROG_ERROR: Some values are invalid. For example,\n                block->header_size must be a multiple of four and\n                between 8 and 1024 inclusive."]
    pub fn lzma_block_compressed_size(block: *mut lzma_block, unpadded_size: lzma_vli) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Calculate Unpadded Size\n\n The Index field stores Unpadded Size and Uncompressed Size. The latter\n can be taken directly from the lzma_block structure after coding a Block,\n but Unpadded Size needs to be calculated from Block Header Size,\n Compressed Size, and size of the Check field. This is where this function\n is needed.\n\n \\param       block   Block options: block->header_size must already be\n                      set with lzma_block_header_size().\n\n \\return      Unpadded Size on success, or zero on error."]
    pub fn lzma_block_unpadded_size(block: *const lzma_block) -> lzma_vli;
}
unsafe extern "C" {
    #[doc = " \\brief       Calculate the total encoded size of a Block\n\n This is equivalent to lzma_block_unpadded_size() except that the returned\n value includes the size of the Block Padding field.\n\n \\param       block   Block options: block->header_size must already be\n                      set with lzma_block_header_size().\n\n \\return      On success, total encoded size of the Block. On error,\n              zero is returned."]
    pub fn lzma_block_total_size(block: *const lzma_block) -> lzma_vli;
}
unsafe extern "C" {
    #[doc = " \\brief       Initialize .xz Block encoder\n\n Valid actions for lzma_code() are LZMA_RUN, LZMA_SYNC_FLUSH (only if the\n filter chain supports it), and LZMA_FINISH.\n\n The Block encoder encodes the Block Data, Block Padding, and Check value.\n It does NOT encode the Block Header which can be encoded with\n lzma_block_header_encode().\n\n \\param       strm    Pointer to lzma_stream that is at least initialized\n                      with LZMA_STREAM_INIT.\n \\param       block   Block options: block->version, block->check,\n                      and block->filters must have been initialized.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: All good, continue with lzma_code().\n              - LZMA_MEM_ERROR\n              - LZMA_OPTIONS_ERROR\n              - LZMA_UNSUPPORTED_CHECK: block->check specifies a Check ID\n                that is not supported by this build of liblzma. Initializing\n                the encoder failed.\n              - LZMA_PROG_ERROR"]
    pub fn lzma_block_encoder(strm: *mut lzma_stream, block: *mut lzma_block) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Initialize .xz Block decoder\n\n Valid actions for lzma_code() are LZMA_RUN and LZMA_FINISH. Using\n LZMA_FINISH is not required. It is supported only for convenience.\n\n The Block decoder decodes the Block Data, Block Padding, and Check value.\n It does NOT decode the Block Header which can be decoded with\n lzma_block_header_decode().\n\n \\param       strm    Pointer to lzma_stream that is at least initialized\n                      with LZMA_STREAM_INIT.\n \\param       block   Block options\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: All good, continue with lzma_code().\n              - LZMA_PROG_ERROR\n              - LZMA_MEM_ERROR"]
    pub fn lzma_block_decoder(strm: *mut lzma_stream, block: *mut lzma_block) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Calculate maximum output size for single-call Block encoding\n\n This is equivalent to lzma_stream_buffer_bound() but for .xz Blocks.\n See the documentation of lzma_stream_buffer_bound().\n\n \\param       uncompressed_size   Size of the data to be encoded with the\n                                  single-call Block encoder.\n\n \\return      Maximum output size in bytes for single-call Block encoding."]
    pub fn lzma_block_buffer_bound(uncompressed_size: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " \\brief       Single-call .xz Block encoder\n\n In contrast to the multi-call encoder initialized with\n lzma_block_encoder(), this function encodes also the Block Header. This\n is required to make it possible to write appropriate Block Header also\n in case the data isn't compressible, and different filter chain has to be\n used to encode the data in uncompressed form using uncompressed chunks\n of the LZMA2 filter.\n\n When the data isn't compressible, header_size, compressed_size, and\n uncompressed_size are set just like when the data was compressible, but\n it is possible that header_size is too small to hold the filter chain\n specified in block->filters, because that isn't necessarily the filter\n chain that was actually used to encode the data. lzma_block_unpadded_size()\n still works normally, because it doesn't read the filters array.\n\n \\param       block       Block options: block->version, block->check,\n                          and block->filters must have been initialized.\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free().\n \\param       in          Beginning of the input buffer\n \\param       in_size     Size of the input buffer\n \\param[out]  out         Beginning of the output buffer\n \\param[out]  out_pos     The next byte will be written to out[*out_pos].\n                          *out_pos is updated only if encoding succeeds.\n \\param       out_size    Size of the out buffer; the first byte into\n                          which no data is written to is out[out_size].\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Encoding was successful.\n              - LZMA_BUF_ERROR: Not enough output buffer space.\n              - LZMA_UNSUPPORTED_CHECK\n              - LZMA_OPTIONS_ERROR\n              - LZMA_MEM_ERROR\n              - LZMA_DATA_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_block_buffer_encode(
        block: *mut lzma_block,
        allocator: *const lzma_allocator,
        in_: *const u8,
        in_size: usize,
        out: *mut u8,
        out_pos: *mut usize,
        out_size: usize,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Single-call uncompressed .xz Block encoder\n\n This is like lzma_block_buffer_encode() except this doesn't try to\n compress the data and instead encodes the data using LZMA2 uncompressed\n chunks. The required output buffer size can be determined with\n lzma_block_buffer_bound().\n\n Since the data won't be compressed, this function ignores block->filters.\n This function doesn't take lzma_allocator because this function doesn't\n allocate any memory from the heap.\n\n \\param       block       Block options: block->version, block->check,\n                          and block->filters must have been initialized.\n \\param       in          Beginning of the input buffer\n \\param       in_size     Size of the input buffer\n \\param[out]  out         Beginning of the output buffer\n \\param[out]  out_pos     The next byte will be written to out[*out_pos].\n                          *out_pos is updated only if encoding succeeds.\n \\param       out_size    Size of the out buffer; the first byte into\n                          which no data is written to is out[out_size].\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Encoding was successful.\n              - LZMA_BUF_ERROR: Not enough output buffer space.\n              - LZMA_UNSUPPORTED_CHECK\n              - LZMA_OPTIONS_ERROR\n              - LZMA_MEM_ERROR\n              - LZMA_DATA_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_block_uncomp_encode(
        block: *mut lzma_block,
        in_: *const u8,
        in_size: usize,
        out: *mut u8,
        out_pos: *mut usize,
        out_size: usize,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Single-call .xz Block decoder\n\n This is single-call equivalent of lzma_block_decoder(), and requires that\n the caller has already decoded Block Header and checked its memory usage.\n\n \\param       block       Block options\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free().\n \\param       in          Beginning of the input buffer\n \\param       in_pos      The next byte will be read from in[*in_pos].\n                          *in_pos is updated only if decoding succeeds.\n \\param       in_size     Size of the input buffer; the first byte that\n                          won't be read is in[in_size].\n \\param[out]  out         Beginning of the output buffer\n \\param[out]  out_pos     The next byte will be written to out[*out_pos].\n                          *out_pos is updated only if encoding succeeds.\n \\param       out_size    Size of the out buffer; the first byte into\n                          which no data is written to is out[out_size].\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Decoding was successful.\n              - LZMA_OPTIONS_ERROR\n              - LZMA_DATA_ERROR\n              - LZMA_MEM_ERROR\n              - LZMA_BUF_ERROR: Output buffer was too small.\n              - LZMA_PROG_ERROR"]
    pub fn lzma_block_buffer_decode(
        block: *mut lzma_block,
        allocator: *const lzma_allocator,
        in_: *const u8,
        in_pos: *mut usize,
        in_size: usize,
        out: *mut u8,
        out_pos: *mut usize,
        out_size: usize,
    ) -> lzma_ret;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lzma_index_s {
    _unused: [u8; 0],
}
#[doc = " \\brief       Opaque data type to hold the Index(es) and other information\n\n lzma_index often holds just one .xz Index and possibly the Stream Flags\n of the same Stream and size of the Stream Padding field. However,\n multiple lzma_indexes can be concatenated with lzma_index_cat() and then\n there may be information about multiple Streams in the same lzma_index.\n\n Notes about thread safety: Only one thread may modify lzma_index at\n a time. All functions that take non-const pointer to lzma_index\n modify it. As long as no thread is modifying the lzma_index, getting\n information from the same lzma_index can be done from multiple threads\n at the same time with functions that take a const pointer to\n lzma_index or use lzma_index_iter. The same iterator must be used\n only by one thread at a time, of course, but there can be as many\n iterators for the same lzma_index as needed."]
pub type lzma_index = lzma_index_s;
#[doc = " \\brief       Iterator to get information about Blocks and Streams"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lzma_index_iter {
    pub stream: lzma_index_iter__bindgen_ty_1,
    pub block: lzma_index_iter__bindgen_ty_2,
    pub internal: [lzma_index_iter__bindgen_ty_3; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lzma_index_iter__bindgen_ty_1 {
    #[doc = " \\brief       Pointer to Stream Flags\n\n This is NULL if Stream Flags have not been set for\n this Stream with lzma_index_stream_flags()."]
    pub flags: *const lzma_stream_flags,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr1: *const ::std::os::raw::c_void,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr2: *const ::std::os::raw::c_void,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr3: *const ::std::os::raw::c_void,
    #[doc = " \\brief       Stream number in the lzma_index\n\n The first Stream is 1."]
    pub number: lzma_vli,
    #[doc = " \\brief       Number of Blocks in the Stream\n\n If this is zero, the block structure below has\n undefined values."]
    pub block_count: lzma_vli,
    #[doc = " \\brief       Compressed start offset of this Stream\n\n The offset is relative to the beginning of the lzma_index\n (i.e. usually the beginning of the .xz file)."]
    pub compressed_offset: lzma_vli,
    #[doc = " \\brief       Uncompressed start offset of this Stream\n\n The offset is relative to the beginning of the lzma_index\n (i.e. usually the beginning of the .xz file)."]
    pub uncompressed_offset: lzma_vli,
    #[doc = " \\brief       Compressed size of this Stream\n\n This includes all headers except the possible\n Stream Padding after this Stream."]
    pub compressed_size: lzma_vli,
    #[doc = " \\brief       Uncompressed size of this Stream"]
    pub uncompressed_size: lzma_vli,
    #[doc = " \\brief       Size of Stream Padding after this Stream\n\n If it hasn't been set with lzma_index_stream_padding(),\n this defaults to zero. Stream Padding is always\n a multiple of four bytes."]
    pub padding: lzma_vli,
    #[doc = " \\private     Reserved member."]
    pub reserved_vli1: lzma_vli,
    #[doc = " \\private     Reserved member."]
    pub reserved_vli2: lzma_vli,
    #[doc = " \\private     Reserved member."]
    pub reserved_vli3: lzma_vli,
    #[doc = " \\private     Reserved member."]
    pub reserved_vli4: lzma_vli,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lzma_index_iter__bindgen_ty_2 {
    #[doc = " \\brief       Block number in the file\n\n The first Block is 1."]
    pub number_in_file: lzma_vli,
    #[doc = " \\brief       Compressed start offset of this Block\n\n This offset is relative to the beginning of the\n lzma_index (i.e. usually the beginning of the .xz file).\n Normally this is where you should seek in the .xz file\n to start decompressing this Block."]
    pub compressed_file_offset: lzma_vli,
    #[doc = " \\brief       Uncompressed start offset of this Block\n\n This offset is relative to the beginning of the lzma_index\n (i.e. usually the beginning of the .xz file).\n\n When doing random-access reading, it is possible that\n the target offset is not exactly at Block boundary. One\n will need to compare the target offset against\n uncompressed_file_offset or uncompressed_stream_offset,\n and possibly decode and throw away some amount of data\n before reaching the target offset."]
    pub uncompressed_file_offset: lzma_vli,
    #[doc = " \\brief       Block number in this Stream\n\n The first Block is 1."]
    pub number_in_stream: lzma_vli,
    #[doc = " \\brief       Compressed start offset of this Block\n\n This offset is relative to the beginning of the Stream\n containing this Block."]
    pub compressed_stream_offset: lzma_vli,
    #[doc = " \\brief       Uncompressed start offset of this Block\n\n This offset is relative to the beginning of the Stream\n containing this Block."]
    pub uncompressed_stream_offset: lzma_vli,
    #[doc = " \\brief       Uncompressed size of this Block\n\n You should pass this to the Block decoder if you will\n decode this Block. It will allow the Block decoder to\n validate the uncompressed size."]
    pub uncompressed_size: lzma_vli,
    #[doc = " \\brief       Unpadded size of this Block\n\n You should pass this to the Block decoder if you will\n decode this Block. It will allow the Block decoder to\n validate the unpadded size."]
    pub unpadded_size: lzma_vli,
    #[doc = " \\brief       Total compressed size\n\n This includes all headers and padding in this Block.\n This is useful if you need to know how many bytes\n the Block decoder will actually read."]
    pub total_size: lzma_vli,
    #[doc = " \\private     Reserved member."]
    pub reserved_vli1: lzma_vli,
    #[doc = " \\private     Reserved member."]
    pub reserved_vli2: lzma_vli,
    #[doc = " \\private     Reserved member."]
    pub reserved_vli3: lzma_vli,
    #[doc = " \\private     Reserved member."]
    pub reserved_vli4: lzma_vli,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr1: *const ::std::os::raw::c_void,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr2: *const ::std::os::raw::c_void,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr3: *const ::std::os::raw::c_void,
    #[doc = " \\private     Reserved member."]
    pub reserved_ptr4: *const ::std::os::raw::c_void,
}
#[doc = " \\private     Internal data\n\n Internal data which is used to store the state of the iterator.\n The exact format may vary between liblzma versions, so don't\n touch these in any way."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union lzma_index_iter__bindgen_ty_3 {
    #[doc = " \\private     Internal member."]
    pub p: *const ::std::os::raw::c_void,
    #[doc = " \\private     Internal member."]
    pub s: usize,
    #[doc = " \\private     Internal member."]
    pub v: lzma_vli,
}
pub const lzma_index_iter_mode_LZMA_INDEX_ITER_ANY: lzma_index_iter_mode = 0;
pub const lzma_index_iter_mode_LZMA_INDEX_ITER_STREAM: lzma_index_iter_mode = 1;
pub const lzma_index_iter_mode_LZMA_INDEX_ITER_BLOCK: lzma_index_iter_mode = 2;
pub const lzma_index_iter_mode_LZMA_INDEX_ITER_NONEMPTY_BLOCK: lzma_index_iter_mode = 3;
#[doc = " \\brief       Operation mode for lzma_index_iter_next()"]
pub type lzma_index_iter_mode = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " \\brief       Calculate memory usage of lzma_index\n\n On disk, the size of the Index field depends on both the number of Records\n stored and the size of the Records (due to variable-length integer\n encoding). When the Index is kept in lzma_index structure, the memory usage\n depends only on the number of Records/Blocks stored in the Index(es), and\n in case of concatenated lzma_indexes, the number of Streams. The size in\n RAM is almost always significantly bigger than in the encoded form on disk.\n\n This function calculates an approximate amount of memory needed to hold\n the given number of Streams and Blocks in lzma_index structure. This\n value may vary between CPU architectures and also between liblzma versions\n if the internal implementation is modified.\n\n \\param       streams Number of Streams\n \\param       blocks  Number of Blocks\n\n \\return      Approximate memory in bytes needed in a lzma_index structure."]
    pub fn lzma_index_memusage(streams: lzma_vli, blocks: lzma_vli) -> u64;
}
unsafe extern "C" {
    #[doc = " \\brief       Calculate the memory usage of an existing lzma_index\n\n This is a shorthand for lzma_index_memusage(lzma_index_stream_count(i),\n lzma_index_block_count(i)).\n\n \\param       i   Pointer to lzma_index structure\n\n \\return      Approximate memory in bytes used by the lzma_index structure."]
    pub fn lzma_index_memused(i: *const lzma_index) -> u64;
}
unsafe extern "C" {
    #[doc = " \\brief       Allocate and initialize a new lzma_index structure\n\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free().\n\n \\return      On success, a pointer to an empty initialized lzma_index is\n              returned. If allocation fails, NULL is returned."]
    pub fn lzma_index_init(allocator: *const lzma_allocator) -> *mut lzma_index;
}
unsafe extern "C" {
    #[doc = " \\brief       Deallocate lzma_index\n\n If i is NULL, this does nothing.\n\n \\param       i           Pointer to lzma_index structure to deallocate\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free()."]
    pub fn lzma_index_end(i: *mut lzma_index, allocator: *const lzma_allocator);
}
unsafe extern "C" {
    #[doc = " \\brief       Add a new Block to lzma_index\n\n \\param       i                 Pointer to a lzma_index structure\n \\param       allocator         lzma_allocator for custom allocator\n                                functions. Set to NULL to use malloc()\n                                and free().\n \\param       unpadded_size     Unpadded Size of a Block. This can be\n                                calculated with lzma_block_unpadded_size()\n                                after encoding or decoding the Block.\n \\param       uncompressed_size Uncompressed Size of a Block. This can be\n                                taken directly from lzma_block structure\n                                after encoding or decoding the Block.\n\n Appending a new Block does not invalidate iterators. For example,\n if an iterator was pointing to the end of the lzma_index, after\n lzma_index_append() it is possible to read the next Block with\n an existing iterator.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_MEM_ERROR\n              - LZMA_DATA_ERROR: Compressed or uncompressed size of the\n                Stream or size of the Index field would grow too big.\n              - LZMA_PROG_ERROR"]
    pub fn lzma_index_append(
        i: *mut lzma_index,
        allocator: *const lzma_allocator,
        unpadded_size: lzma_vli,
        uncompressed_size: lzma_vli,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Set the Stream Flags\n\n Set the Stream Flags of the last (and typically the only) Stream\n in lzma_index. This can be useful when reading information from the\n lzma_index, because to decode Blocks, knowing the integrity check type\n is needed.\n\n \\param       i              Pointer to lzma_index structure\n \\param       stream_flags   Pointer to lzma_stream_flags structure. This\n                             is copied into the internal preallocated\n                             structure, so the caller doesn't need to keep\n                             the flags' data available after calling this\n                             function.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_OPTIONS_ERROR: Unsupported stream_flags->version.\n              - LZMA_PROG_ERROR"]
    pub fn lzma_index_stream_flags(
        i: *mut lzma_index,
        stream_flags: *const lzma_stream_flags,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Get the types of integrity Checks\n\n If lzma_index_stream_flags() is used to set the Stream Flags for\n every Stream, lzma_index_checks() can be used to get a bitmask to\n indicate which Check types have been used. It can be useful e.g. if\n showing the Check types to the user.\n\n The bitmask is 1 << check_id, e.g. CRC32 is 1 << 1 and SHA-256 is 1 << 10.\n These masks are defined for convenience as LZMA_INDEX_CHECK_MASK_XXX\n\n \\param       i   Pointer to lzma_index structure\n\n \\return      Bitmask indicating which Check types are used in the lzma_index"]
    pub fn lzma_index_checks(i: *const lzma_index) -> u32;
}
unsafe extern "C" {
    #[doc = " \\brief       Set the amount of Stream Padding\n\n Set the amount of Stream Padding of the last (and typically the only)\n Stream in the lzma_index. This is needed when planning to do random-access\n reading within multiple concatenated Streams.\n\n By default, the amount of Stream Padding is assumed to be zero bytes.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_DATA_ERROR: The file size would grow too big.\n              - LZMA_PROG_ERROR"]
    pub fn lzma_index_stream_padding(i: *mut lzma_index, stream_padding: lzma_vli) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Get the number of Streams\n\n \\param       i   Pointer to lzma_index structure\n\n \\return      Number of Streams in the lzma_index"]
    pub fn lzma_index_stream_count(i: *const lzma_index) -> lzma_vli;
}
unsafe extern "C" {
    #[doc = " \\brief       Get the number of Blocks\n\n This returns the total number of Blocks in lzma_index. To get number\n of Blocks in individual Streams, use lzma_index_iter.\n\n \\param       i   Pointer to lzma_index structure\n\n \\return      Number of blocks in the lzma_index"]
    pub fn lzma_index_block_count(i: *const lzma_index) -> lzma_vli;
}
unsafe extern "C" {
    #[doc = " \\brief       Get the size of the Index field as bytes\n\n This is needed to verify the Backward Size field in the Stream Footer.\n\n \\param       i   Pointer to lzma_index structure\n\n \\return      Size in bytes of the Index"]
    pub fn lzma_index_size(i: *const lzma_index) -> lzma_vli;
}
unsafe extern "C" {
    #[doc = " \\brief       Get the total size of the Stream\n\n If multiple lzma_indexes have been combined, this works as if the Blocks\n were in a single Stream. This is useful if you are going to combine\n Blocks from multiple Streams into a single new Stream.\n\n \\param       i   Pointer to lzma_index structure\n\n \\return      Size in bytes of the Stream (if all Blocks are combined\n              into one Stream)."]
    pub fn lzma_index_stream_size(i: *const lzma_index) -> lzma_vli;
}
unsafe extern "C" {
    #[doc = " \\brief       Get the total size of the Blocks\n\n This doesn't include the Stream Header, Stream Footer, Stream Padding,\n or Index fields.\n\n \\param       i   Pointer to lzma_index structure\n\n \\return      Size in bytes of all Blocks in the Stream(s)"]
    pub fn lzma_index_total_size(i: *const lzma_index) -> lzma_vli;
}
unsafe extern "C" {
    #[doc = " \\brief       Get the total size of the file\n\n When no lzma_indexes have been combined with lzma_index_cat() and there is\n no Stream Padding, this function is identical to lzma_index_stream_size().\n If multiple lzma_indexes have been combined, this includes also the headers\n of each separate Stream and the possible Stream Padding fields.\n\n \\param       i   Pointer to lzma_index structure\n\n \\return      Total size of the .xz file in bytes"]
    pub fn lzma_index_file_size(i: *const lzma_index) -> lzma_vli;
}
unsafe extern "C" {
    #[doc = " \\brief       Get the uncompressed size of the file\n\n \\param       i   Pointer to lzma_index structure\n\n \\return      Size in bytes of the uncompressed data in the file"]
    pub fn lzma_index_uncompressed_size(i: *const lzma_index) -> lzma_vli;
}
unsafe extern "C" {
    #[doc = " \\brief       Initialize an iterator\n\n This function associates the iterator with the given lzma_index, and calls\n lzma_index_iter_rewind() on the iterator.\n\n This function doesn't allocate any memory, thus there is no\n lzma_index_iter_end(). The iterator is valid as long as the\n associated lzma_index is valid, that is, until lzma_index_end() or\n using it as source in lzma_index_cat(). Specifically, lzma_index doesn't\n become invalid if new Blocks are added to it with lzma_index_append() or\n if it is used as the destination in lzma_index_cat().\n\n It is safe to make copies of an initialized lzma_index_iter, for example,\n to easily restart reading at some particular position.\n\n \\param       iter    Pointer to a lzma_index_iter structure\n \\param       i       lzma_index to which the iterator will be associated"]
    pub fn lzma_index_iter_init(iter: *mut lzma_index_iter, i: *const lzma_index);
}
unsafe extern "C" {
    #[doc = " \\brief       Rewind the iterator\n\n Rewind the iterator so that next call to lzma_index_iter_next() will\n return the first Block or Stream.\n\n \\param       iter    Pointer to a lzma_index_iter structure"]
    pub fn lzma_index_iter_rewind(iter: *mut lzma_index_iter);
}
unsafe extern "C" {
    #[doc = " \\brief       Get the next Block or Stream\n\n \\param       iter    Iterator initialized with lzma_index_iter_init()\n \\param       mode    Specify what kind of information the caller wants\n                      to get. See lzma_index_iter_mode for details.\n\n \\return      lzma_bool:\n              - true if no Block or Stream matching the mode is found.\n                *iter is not updated (failure).\n              - false if the next Block or Stream matching the mode was\n                found. *iter is updated (success)."]
    pub fn lzma_index_iter_next(
        iter: *mut lzma_index_iter,
        mode: lzma_index_iter_mode,
    ) -> lzma_bool;
}
unsafe extern "C" {
    #[doc = " \\brief       Locate a Block\n\n If it is possible to seek in the .xz file, it is possible to parse\n the Index field(s) and use lzma_index_iter_locate() to do random-access\n reading with granularity of Block size.\n\n If the target is smaller than the uncompressed size of the Stream (can be\n checked with lzma_index_uncompressed_size()):\n  - Information about the Stream and Block containing the requested\n    uncompressed offset is stored into *iter.\n  - Internal state of the iterator is adjusted so that\n    lzma_index_iter_next() can be used to read subsequent Blocks or Streams.\n\n If the target is greater than the uncompressed size of the Stream, *iter\n is not modified.\n\n \\param       iter    Iterator that was earlier initialized with\n                      lzma_index_iter_init().\n \\param       target  Uncompressed target offset which the caller would\n                      like to locate from the Stream\n\n \\return      lzma_bool:\n              - true if the target is greater than or equal to the\n                uncompressed size of the Stream (failure)\n              - false if the target is smaller than the uncompressed size\n                of the Stream (success)"]
    pub fn lzma_index_iter_locate(iter: *mut lzma_index_iter, target: lzma_vli) -> lzma_bool;
}
unsafe extern "C" {
    #[doc = " \\brief       Concatenate lzma_indexes\n\n Concatenating lzma_indexes is useful when doing random-access reading in\n multi-Stream .xz file, or when combining multiple Streams into single\n Stream.\n\n \\param[out]  dest      lzma_index after which src is appended\n \\param       src       lzma_index to be appended after dest. If this\n                        function succeeds, the memory allocated for src\n                        is freed or moved to be part of dest, and all\n                        iterators pointing to src will become invalid.\n \\param       allocator lzma_allocator for custom allocator functions.\n                        Set to NULL to use malloc() and free().\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: lzma_indexes were concatenated successfully.\n                src is now a dangling pointer.\n              - LZMA_DATA_ERROR: *dest would grow too big.\n              - LZMA_MEM_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_index_cat(
        dest: *mut lzma_index,
        src: *mut lzma_index,
        allocator: *const lzma_allocator,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Duplicate lzma_index\n\n \\param       i         Pointer to lzma_index structure to be duplicated\n \\param       allocator lzma_allocator for custom allocator functions.\n                        Set to NULL to use malloc() and free().\n\n \\return      A copy of the lzma_index, or NULL if memory allocation failed."]
    pub fn lzma_index_dup(
        i: *const lzma_index,
        allocator: *const lzma_allocator,
    ) -> *mut lzma_index;
}
unsafe extern "C" {
    #[doc = " \\brief       Initialize .xz Index encoder\n\n \\param       strm        Pointer to properly prepared lzma_stream\n \\param       i           Pointer to lzma_index which should be encoded.\n\n The valid 'action' values for lzma_code() are LZMA_RUN and LZMA_FINISH.\n It is enough to use only one of them (you can choose freely).\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Initialization succeeded, continue with lzma_code().\n              - LZMA_MEM_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_index_encoder(strm: *mut lzma_stream, i: *const lzma_index) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Initialize .xz Index decoder\n\n \\param       strm        Pointer to properly prepared lzma_stream\n \\param[out]  i           The decoded Index will be made available via\n                          this pointer. Initially this function will\n                          set *i to NULL (the old value is ignored). If\n                          decoding succeeds (lzma_code() returns\n                          LZMA_STREAM_END), *i will be set to point\n                          to a new lzma_index, which the application\n                          has to later free with lzma_index_end().\n \\param       memlimit    How much memory the resulting lzma_index is\n                          allowed to require. liblzma 5.2.3 and earlier\n                          don't allow 0 here and return LZMA_PROG_ERROR;\n                          later versions treat 0 as if 1 had been specified.\n\n Valid 'action' arguments to lzma_code() are LZMA_RUN and LZMA_FINISH.\n There is no need to use LZMA_FINISH, but it's allowed because it may\n simplify certain types of applications.\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Initialization succeeded, continue with lzma_code().\n              - LZMA_MEM_ERROR\n              - LZMA_PROG_ERROR\n\n \\note        liblzma 5.2.3 and older list also LZMA_MEMLIMIT_ERROR here\n              but that error code has never been possible from this\n              initialization function."]
    pub fn lzma_index_decoder(
        strm: *mut lzma_stream,
        i: *mut *mut lzma_index,
        memlimit: u64,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Single-call .xz Index encoder\n\n \\note        This function doesn't take allocator argument since all\n              the internal data is allocated on stack.\n\n \\param       i         lzma_index to be encoded\n \\param[out]  out       Beginning of the output buffer\n \\param[out]  out_pos   The next byte will be written to out[*out_pos].\n                        *out_pos is updated only if encoding succeeds.\n \\param       out_size  Size of the out buffer; the first byte into\n                        which no data is written to is out[out_size].\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Encoding was successful.\n              - LZMA_BUF_ERROR: Output buffer is too small. Use\n                lzma_index_size() to find out how much output\n                space is needed.\n              - LZMA_PROG_ERROR\n"]
    pub fn lzma_index_buffer_encode(
        i: *const lzma_index,
        out: *mut u8,
        out_pos: *mut usize,
        out_size: usize,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Single-call .xz Index decoder\n\n \\param[out]  i           If decoding succeeds, *i will point to a new\n                          lzma_index, which the application has to\n                          later free with lzma_index_end(). If an error\n                          occurs, *i will be NULL. The old value of *i\n                          is always ignored and thus doesn't need to be\n                          initialized by the caller.\n \\param[out]  memlimit    Pointer to how much memory the resulting\n                          lzma_index is allowed to require. The value\n                          pointed by this pointer is modified if and only\n                          if LZMA_MEMLIMIT_ERROR is returned.\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free().\n \\param       in          Beginning of the input buffer\n \\param       in_pos      The next byte will be read from in[*in_pos].\n                          *in_pos is updated only if decoding succeeds.\n \\param       in_size     Size of the input buffer; the first byte that\n                          won't be read is in[in_size].\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: Decoding was successful.\n              - LZMA_MEM_ERROR\n              - LZMA_MEMLIMIT_ERROR: Memory usage limit was reached.\n                The minimum required memlimit value was stored to *memlimit.\n              - LZMA_DATA_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_index_buffer_decode(
        i: *mut *mut lzma_index,
        memlimit: *mut u64,
        allocator: *const lzma_allocator,
        in_: *const u8,
        in_pos: *mut usize,
        in_size: usize,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Initialize a .xz file information decoder\n\n This decoder decodes the Stream Header, Stream Footer, Index, and\n Stream Padding field(s) from the input .xz file and stores the resulting\n combined index in *dest_index. This information can be used to get the\n uncompressed file size with lzma_index_uncompressed_size(*dest_index) or,\n for example, to implement random access reading by locating the Blocks\n in the Streams.\n\n To get the required information from the .xz file, lzma_code() may ask\n the application to seek in the input file by returning LZMA_SEEK_NEEDED\n and having the target file position specified in lzma_stream.seek_pos.\n The number of seeks required depends on the input file and how big buffers\n the application provides. When possible, the decoder will seek backward\n and forward in the given buffer to avoid useless seek requests. Thus, if\n the application provides the whole file at once, no external seeking will\n be required (that is, lzma_code() won't return LZMA_SEEK_NEEDED).\n\n The value in lzma_stream.total_in can be used to estimate how much data\n liblzma had to read to get the file information. However, due to seeking\n and the way total_in is updated, the value of total_in will be somewhat\n inaccurate (a little too big). Thus, total_in is a good estimate but don't\n expect to see the same exact value for the same file if you change the\n input buffer size or switch to a different liblzma version.\n\n Valid 'action' arguments to lzma_code() are LZMA_RUN and LZMA_FINISH.\n You only need to use LZMA_RUN; LZMA_FINISH is only supported because it\n might be convenient for some applications. If you use LZMA_FINISH and if\n lzma_code() asks the application to seek, remember to reset 'action' back\n to LZMA_RUN unless you hit the end of the file again.\n\n Possible return values from lzma_code():\n   - LZMA_OK: All OK so far, more input needed\n   - LZMA_SEEK_NEEDED: Provide more input starting from the absolute\n     file position strm->seek_pos\n   - LZMA_STREAM_END: Decoding was successful, *dest_index has been set\n   - LZMA_FORMAT_ERROR: The input file is not in the .xz format (the\n     expected magic bytes were not found from the beginning of the file)\n   - LZMA_OPTIONS_ERROR: File looks valid but contains headers that aren't\n     supported by this version of liblzma\n   - LZMA_DATA_ERROR: File is corrupt\n   - LZMA_BUF_ERROR\n   - LZMA_MEM_ERROR\n   - LZMA_MEMLIMIT_ERROR\n   - LZMA_PROG_ERROR\n\n \\param       strm        Pointer to a properly prepared lzma_stream\n \\param[out]  dest_index  Pointer to a pointer where the decoder will put\n                          the decoded lzma_index. The old value\n                          of *dest_index is ignored (not freed).\n \\param       memlimit    How much memory the resulting lzma_index is\n                          allowed to require. Use UINT64_MAX to\n                          effectively disable the limiter.\n \\param       file_size   Size of the input .xz file\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_MEM_ERROR\n              - LZMA_PROG_ERROR"]
    pub fn lzma_file_info_decoder(
        strm: *mut lzma_stream,
        dest_index: *mut *mut lzma_index,
        memlimit: u64,
        file_size: u64,
    ) -> lzma_ret;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lzma_index_hash_s {
    _unused: [u8; 0],
}
#[doc = " \\brief       Opaque data type to hold the Index hash"]
pub type lzma_index_hash = lzma_index_hash_s;
unsafe extern "C" {
    #[doc = " \\brief       Allocate and initialize a new lzma_index_hash structure\n\n If index_hash is NULL, this function allocates and initializes a new\n lzma_index_hash structure and returns a pointer to it. If allocation\n fails, NULL is returned.\n\n If index_hash is non-NULL, this function reinitializes the lzma_index_hash\n structure and returns the same pointer. In this case, return value cannot\n be NULL or a different pointer than the index_hash that was given as\n an argument.\n\n \\param       index_hash  Pointer to a lzma_index_hash structure or NULL.\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free().\n\n \\return      Initialized lzma_index_hash structure on success or\n              NULL on failure."]
    pub fn lzma_index_hash_init(
        index_hash: *mut lzma_index_hash,
        allocator: *const lzma_allocator,
    ) -> *mut lzma_index_hash;
}
unsafe extern "C" {
    #[doc = " \\brief       Deallocate lzma_index_hash structure\n\n \\param       index_hash  Pointer to a lzma_index_hash structure to free.\n \\param       allocator   lzma_allocator for custom allocator functions.\n                          Set to NULL to use malloc() and free()."]
    pub fn lzma_index_hash_end(index_hash: *mut lzma_index_hash, allocator: *const lzma_allocator);
}
unsafe extern "C" {
    #[doc = " \\brief       Add a new Record to an Index hash\n\n \\param       index_hash        Pointer to a lzma_index_hash structure\n \\param       unpadded_size     Unpadded Size of a Block\n \\param       uncompressed_size Uncompressed Size of a Block\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK\n              - LZMA_DATA_ERROR: Compressed or uncompressed size of the\n                Stream or size of the Index field would grow too big.\n              - LZMA_PROG_ERROR: Invalid arguments or this function is being\n                used when lzma_index_hash_decode() has already been used."]
    pub fn lzma_index_hash_append(
        index_hash: *mut lzma_index_hash,
        unpadded_size: lzma_vli,
        uncompressed_size: lzma_vli,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Decode and validate the Index field\n\n After telling the sizes of all Blocks with lzma_index_hash_append(),\n the actual Index field is decoded with this function. Specifically,\n once decoding of the Index field has been started, no more Records\n can be added using lzma_index_hash_append().\n\n This function doesn't use lzma_stream structure to pass the input data.\n Instead, the input buffer is specified using three arguments. This is\n because it matches better the internal APIs of liblzma.\n\n \\param       index_hash      Pointer to a lzma_index_hash structure\n \\param       in              Pointer to the beginning of the input buffer\n \\param[out]  in_pos          in[*in_pos] is the next byte to process\n \\param       in_size         in[in_size] is the first byte not to process\n\n \\return      Possible lzma_ret values:\n              - LZMA_OK: So far good, but more input is needed.\n              - LZMA_STREAM_END: Index decoded successfully and it matches\n                the Records given with lzma_index_hash_append().\n              - LZMA_DATA_ERROR: Index is corrupt or doesn't match the\n                information given with lzma_index_hash_append().\n              - LZMA_BUF_ERROR: Cannot progress because *in_pos >= in_size.\n              - LZMA_PROG_ERROR"]
    pub fn lzma_index_hash_decode(
        index_hash: *mut lzma_index_hash,
        in_: *const u8,
        in_pos: *mut usize,
        in_size: usize,
    ) -> lzma_ret;
}
unsafe extern "C" {
    #[doc = " \\brief       Get the size of the Index field as bytes\n\n This is needed to verify the Backward Size field in the Stream Footer.\n\n \\param       index_hash      Pointer to a lzma_index_hash structure\n\n \\return      Size of the Index field in bytes."]
    pub fn lzma_index_hash_size(index_hash: *const lzma_index_hash) -> lzma_vli;
}
unsafe extern "C" {
    #[doc = " \\brief       Get the total amount of physical memory (RAM) in bytes\n\n This function may be useful when determining a reasonable memory\n usage limit for decompressing or how much memory it is OK to use\n for compressing.\n\n \\return      On success, the total amount of physical memory in bytes\n              is returned. If the amount of RAM cannot be determined,\n              zero is returned. This can happen if an error occurs\n              or if there is no code in liblzma to detect the amount\n              of RAM on the specific operating system."]
    pub fn lzma_physmem() -> u64;
}
unsafe extern "C" {
    #[doc = " \\brief       Get the number of processor cores or threads\n\n This function may be useful when determining how many threads to use.\n If the hardware supports more than one thread per CPU core, the number\n of hardware threads is returned if that information is available.\n\n \\return      On success, the number of available CPU threads or cores is\n              returned. If this information isn't available or an error\n              occurs, zero is returned."]
    pub fn lzma_cputhreads() -> u32;
}
